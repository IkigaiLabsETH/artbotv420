/**
 * Type definitions for the multi-agent system
 * Defines agent roles, interfaces, and communication structures
 */

/**
 * Enum defining the different roles that agents can have in the system
 */
export enum AgentRole {
  DIRECTOR = 'director',
  IDEATOR = 'ideator',
  STYLIST = 'stylist',
  REFINER = 'flux_refiner',
  CRITIC = 'critic',
  CHARACTER_GENERATOR = 'character_generator',
  METADATA_GENERATOR = 'metadata_generator'
}

/**
 * Agent status enum
 */
export enum AgentStatus {
  IDLE = 'idle',
  BUSY = 'busy',
  ERROR = 'error',
  SUCCESS = 'success'
}

/**
 * Message direction enum
 */
export enum MessageDirection {
  INCOMING = 'incoming',
  OUTGOING = 'outgoing'
}

/**
 * Base interface for all agents
 */
export interface Agent {
  id: string;
  role: AgentRole;
  status: AgentStatus;
  initialize(): Promise<void>;
  process(context: AgentContext): Promise<AgentResult>;
  handleMessage(message: AgentMessage): Promise<void>;
}

/**
 * Context passed to agents for processing
 */
export interface AgentContext {
  projectId: string;
  concept?: string;
  prompt?: string;
  style?: string;
  styleConfig?: any;
  modelConfig?: any;
  previousResults?: any;
  messages: AgentMessage[];
  [key: string]: any;
}

/**
 * Result returned by agents after processing
 */
export interface AgentResult {
  success: boolean;
  output?: any;
  error?: Error;
  messages: AgentMessage[];
  [key: string]: any;
}

/**
 * Message exchanged between agents
 */
export interface AgentMessage {
  id: string;
  timestamp: Date;
  from: AgentRole;
  to: AgentRole | 'all';
  direction: MessageDirection;
  type: string;
  content: any;
  metadata?: Record<string, any>;
}

/**
 * Character identity generated by character generator agent
 */
export interface CharacterIdentity {
  name: string;
  title: string;
  nickname?: string;
  personality: string[];
  backstory: string;
  traits?: Record<string, any>;
  occupation?: string;
  specialItems?: string[];
}

/**
 * Specific agent roles and interfaces
 */

/**
 * Director agent that coordinates the overall process
 */
export interface DirectorAgent extends Agent {
  role: AgentRole.DIRECTOR;
  createWorkflow(concept: string, style: string): Promise<AgentContext>;
  assignTask(agentRole: AgentRole, task: any): Promise<void>;
  collectResults(): Promise<AgentResult>;
  registerAgent(agent: Agent): void;
  getAgent(role: AgentRole): Agent | undefined;
}

/**
 * Ideator agent that generates creative ideas
 */
export interface IdeatorAgent extends Agent {
  role: AgentRole.IDEATOR;
  generateIdea(concept: string): Promise<string>;
  enhancePrompt(concept: string): Promise<string>;
  suggestVariations(concept: string, count: number): Promise<string[]>;
}

/**
 * Stylist agent that handles styling
 */
export interface StylistAgent extends Agent {
  role: AgentRole.STYLIST;
  applyStyle(prompt: string, style: string): Promise<string>;
  suggestStyleEnhancements(prompt: string, style: string): Promise<Record<string, any>>;
}

/**
 * Refiner agent that improves generated images
 */
export interface RefinerAgent extends Agent {
  role: AgentRole.REFINER;
  refinePrompt(prompt: string, feedback?: string): Promise<string>;
  optimizeForModel(prompt: string, model: string): Promise<string>;
}

/**
 * Critic agent that evaluates results
 */
export interface CriticAgent extends Agent {
  role: AgentRole.CRITIC;
  evaluateResult(result: any): Promise<{
    score: number;
    feedback: string;
    improvements: string[];
  }>;
}

/**
 * Character generator agent
 */
export interface CharacterGeneratorAgent extends Agent {
  role: AgentRole.CHARACTER_GENERATOR;
  generateCharacter(concept: string): Promise<CharacterIdentity>;
}

/**
 * Metadata generator agent
 */
export interface MetadataGeneratorAgent extends Agent {
  role: AgentRole.METADATA_GENERATOR;
  generateMetadata(result: any, character: CharacterIdentity): Promise<Record<string, any>>;
}

/**
 * Multi-agent system configuration
 */
export interface MultiAgentSystemConfig {
  aiService: any;
  replicateService: any;
  memorySystem?: any;
  styleService?: any;
  outputDir?: string;
  agents?: Agent[];
} 