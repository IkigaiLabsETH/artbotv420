
import { createRequire } from 'module';
const require = createRequire(import.meta.url);

import {
  branchExists,
  createBranch,
  createPullRequest,
  ensureDirectory,
  forkExists,
  forkRepository,
  getFileContent,
  getGitHubToken,
  getRegistrySettings,
  updateFile
} from "./chunk-VI5W7VMD.js";
import {
  execa
} from "./chunk-LIA2BGYJ.js";
import {
  logger,
  require_semver
} from "./chunk-H473MSWF.js";
import {
  __toESM
} from "./chunk-567UPUC7.js";

// src/utils/plugin-publisher.ts
import { promises as fs } from "node:fs";
import path from "node:path";
var import_semver = __toESM(require_semver(), 1);
async function testPublishToNpm(cwd) {
  try {
    await execa("npm", ["whoami"]);
    logger.info("\u2713 Logged in to npm");
    logger.info("Testing build...");
    await execa("npm", ["run", "build", "--dry-run"], { cwd });
    logger.info("\u2713 Build test successful");
    const pkgJson = JSON.parse(await fs.readFile(path.join(cwd, "package.json"), "utf-8"));
    await execa("npm", ["access", "ls-packages"], { cwd });
    logger.info("\u2713 Have publish permissions");
    return true;
  } catch (error) {
    logger.error("Test failed:", error);
    if (error instanceof Error) {
      logger.error(`Error message: ${error.message}`);
      logger.error(`Error stack: ${error.stack}`);
    }
    return false;
  }
}
async function testPublishToGitHub(cwd, packageJson, username) {
  try {
    const token = await getGitHubToken();
    if (!token) {
      logger.error("GitHub token not found");
      return false;
    }
    logger.info("\u2713 GitHub token found");
    const response = await fetch("https://api.github.com/user", {
      headers: { Authorization: `token ${token}` }
    });
    if (!response.ok) {
      logger.error("Invalid GitHub token or insufficient permissions");
      return false;
    }
    logger.info("\u2713 GitHub token is valid");
    const settings = await getRegistrySettings();
    const [registryOwner, registryRepo] = settings.defaultRegistry.split("/");
    logger.info(`Testing with registry: ${registryOwner}/${registryRepo}`);
    const hasFork = await forkExists(token, registryOwner, registryRepo, username);
    logger.info(hasFork ? "\u2713 Fork exists" : "\u2713 Can create fork");
    if (!hasFork) {
      logger.info("Creating fork...");
      const forkCreated = await forkRepository(token, registryOwner, registryRepo);
      if (!forkCreated) {
        logger.error("Failed to create fork");
        return false;
      }
      logger.info("\u2713 Fork created");
      await new Promise((resolve) => setTimeout(resolve, 3e3));
    }
    const branchName = `test-${packageJson.name.replace(/^@elizaos\//, "")}-${packageJson.version}`;
    const hasBranch = await branchExists(token, username, registryRepo, branchName);
    logger.info(hasBranch ? "\u2713 Test branch exists" : "\u2713 Can create branch");
    if (!hasBranch) {
      logger.info("Creating branch...");
      const branchCreated = await createBranch(token, username, registryRepo, branchName, "main");
      if (!branchCreated) {
        logger.error("Failed to create branch");
        return false;
      }
      logger.info("\u2713 Branch created");
    }
    const simpleName = packageJson.name.replace(/^@elizaos\//, "").replace(/[^a-zA-Z0-9-]/g, "-");
    const testPath = `test-files/${simpleName}-test.json`;
    logger.info(`Attempting to create test file: ${testPath} in branch: ${branchName}`);
    const dirCreated = await ensureDirectory(
      token,
      username,
      registryRepo,
      "test-files",
      branchName
    );
    if (!dirCreated) {
      logger.warn("Failed to create test directory, but continuing with file creation");
    }
    const canUpdate = await updateFile(
      token,
      username,
      registryRepo,
      testPath,
      JSON.stringify({ test: true, timestamp: (/* @__PURE__ */ new Date()).toISOString() }),
      "Test file update",
      branchName
      // Use the test branch instead of main
    );
    if (!canUpdate) {
      logger.error("Cannot update files in repository");
      return false;
    }
    logger.info("\u2713 Can create and update files");
    return true;
  } catch (error) {
    logger.error("Test failed:", error);
    return false;
  }
}
async function publishToGitHub(cwd, packageJson, cliVersion, username, isTest = false) {
  const token = await getGitHubToken();
  if (!token) {
    logger.error("GitHub token not found. Please set it using the login command.");
    return false;
  }
  if (isTest) {
    logger.info("Running in test mode - no actual changes will be made");
  }
  const settings = await getRegistrySettings();
  const [registryOwner, registryRepo] = settings.defaultRegistry.split("/");
  const hasFork = await forkExists(token, registryOwner, registryRepo, username);
  let forkFullName;
  if (!hasFork && !isTest) {
    logger.info(`Creating fork of ${settings.defaultRegistry}...`);
    const fork = await forkRepository(token, registryOwner, registryRepo);
    if (!fork) {
      logger.error("Failed to fork registry repository.");
      return false;
    }
    forkFullName = fork;
  } else {
    forkFullName = `${username}/${registryRepo}`;
    logger.info(`Using existing fork: ${forkFullName}`);
  }
  const entityType = packageJson.type || "plugin";
  const branchName = `${entityType}-${packageJson.name.replace(/^@elizaos\//, "")}-${packageJson.version}`;
  const hasBranch = await branchExists(token, username, registryRepo, branchName);
  if (!hasBranch && !isTest) {
    logger.info(`Creating branch ${branchName}...`);
    const created = await createBranch(token, username, registryRepo, branchName);
    if (!created) {
      logger.error("Failed to create branch.");
      return false;
    }
  }
  const packageName = packageJson.name.replace(/^@elizaos\//, "");
  const packagePath = `packages/${packageName}.json`;
  const existingContent = await getFileContent(token, registryOwner, registryRepo, packagePath);
  let metadata;
  const currentDate = (/* @__PURE__ */ new Date()).toISOString();
  const repositoryUrl = packageJson.repository?.url || `github:${username}/${packageName}`;
  if (existingContent) {
    try {
      metadata = JSON.parse(existingContent);
      if (metadata.versions.some((v) => v.version === packageJson.version)) {
        logger.error(`Version ${packageJson.version} already exists in registry.`);
        return false;
      }
      metadata.versions.push({
        version: packageJson.version,
        gitBranch: packageJson.version,
        gitTag: `v${packageJson.version}`,
        runtimeVersion: cliVersion,
        releaseDate: currentDate,
        deprecated: false
      });
      metadata.latestVersion = packageJson.version;
      if (!import_semver.default.prerelease(packageJson.version) && (!metadata.latestStable || import_semver.default.gt(packageJson.version, metadata.latestStable))) {
        metadata.latestStable = packageJson.version;
      }
      if (packageJson.type) {
        metadata.type = packageJson.type;
        metadata.installable = packageJson.type === "plugin";
      }
      if (packageJson.platform) {
        metadata.platform = packageJson.platform;
      }
      if (packageJson.keywords?.length) {
        metadata.tags = packageJson.keywords;
      }
      if (packageJson.categories?.length) {
        metadata.categories = packageJson.categories;
      }
    } catch (error) {
      logger.error(`Error parsing existing metadata: ${error.message}`);
      logger.info("Creating new metadata");
      metadata = null;
    }
  }
  if (!metadata) {
    metadata = {
      name: packageJson.name,
      description: packageJson.description || "",
      repository: {
        type: repositoryUrl.startsWith("npm:") ? "npm" : "git",
        url: repositoryUrl
      },
      maintainers: [
        {
          name: username,
          github: username
        }
      ],
      categories: packageJson.categories || [],
      tags: packageJson.keywords || [],
      versions: [
        {
          version: packageJson.version,
          gitBranch: packageJson.version,
          gitTag: `v${packageJson.version}`,
          runtimeVersion: cliVersion,
          releaseDate: currentDate,
          deprecated: false
        }
      ],
      latestStable: import_semver.default.prerelease(packageJson.version) ? null : packageJson.version,
      latestVersion: packageJson.version,
      type: entityType,
      installable: entityType === "plugin"
      // Only plugins are installable
    };
    if (packageJson.platform) {
      metadata.platform = packageJson.platform;
    }
  }
  if (!isTest) {
    const updated = await updateFile(
      token,
      username,
      registryRepo,
      packagePath,
      JSON.stringify(metadata, null, 2),
      `Update ${packageJson.name} to version ${packageJson.version}`,
      branchName
    );
    if (!updated) {
      logger.error("Failed to update package metadata.");
      return false;
    }
    try {
      const indexContent = await getFileContent(token, username, registryRepo, "index.json");
      if (indexContent) {
        const index = JSON.parse(indexContent);
        const isNew = !index.__v2?.packages?.[packageJson.name];
        if (!index.__v2) {
          index.__v2 = {
            version: "2.0.0",
            packages: {},
            categories: {},
            types: {
              plugin: [],
              project: []
            }
          };
        }
        if (!index.__v2.types) {
          index.__v2.types = {
            plugin: [],
            project: []
          };
        }
        index.__v2.packages[packageJson.name] = packagePath;
        const type = packageJson.type || "plugin";
        if (!index.__v2.types[type]) {
          index.__v2.types[type] = [];
        }
        if (!index.__v2.types[type].includes(packageJson.name)) {
          index.__v2.types[type].push(packageJson.name);
        }
        metadata.categories.forEach((category) => {
          if (!index.__v2.categories[category]) {
            index.__v2.categories[category] = [];
          }
          if (!index.__v2.categories[category].includes(packageJson.name)) {
            index.__v2.categories[category].push(packageJson.name);
          }
        });
        const indexUpdated = await updateFile(
          token,
          username,
          registryRepo,
          "index.json",
          JSON.stringify(index, null, 2),
          `${isNew ? "Add" : "Update"} ${packageJson.name} in registry index`,
          branchName
        );
        if (!indexUpdated) {
          logger.warn("Failed to update registry index.");
        }
      }
    } catch (error) {
      logger.warn(`Failed to update index.json: ${error.message}`);
    }
    const prCreated = await createPullRequest(
      token,
      registryOwner,
      registryRepo,
      `Add ${packageJson.name}@${packageJson.version} to registry`,
      `This PR adds ${packageJson.name} version ${packageJson.version} to the registry.

- Type: ${packageJson.type || "plugin"}
- Installable: ${(packageJson.type || "plugin") === "plugin" ? "Yes" : "No - Project type"}
- Package name: ${packageJson.name}
- Version: ${packageJson.version}
- Runtime version: ${cliVersion}
- Description: ${packageJson.description || "No description provided"}
- Repository: ${metadata.repository.url}
- Platform: ${metadata.platform || "not specified"}
- Categories: ${metadata.categories.join(", ") || "none"}
- Tags: ${metadata.tags.join(", ") || "none"}

Submitted by: @${username}`,
      `${username}:${branchName}`,
      "main"
    );
    if (!prCreated) {
      logger.error("Failed to create pull request.");
      return false;
    }
    logger.success(`Pull request created: ${prCreated}`);
  } else {
    logger.info("Test successful - all checks passed");
    logger.info("Would create:");
    logger.info(`- Branch: ${branchName}`);
    logger.info(`- Package file: ${packagePath}`);
    logger.info(
      `- Type: ${packageJson.type || "plugin"} (${(packageJson.type || "plugin") === "plugin" ? "installable" : "not installable"})`
    );
    logger.info(`- Pull request: Add ${packageJson.name}@${packageJson.version} to registry`);
  }
  return true;
}

export {
  testPublishToNpm,
  testPublishToGitHub,
  publishToGitHub
};
