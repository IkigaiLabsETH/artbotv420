
import { createRequire } from 'module';
const require = createRequire(import.meta.url);

import {
  buildProject
} from "./chunk-5GTCUWAK.js";
import {
  execa
} from "./chunk-LIA2BGYJ.js";
import {
  handleError
} from "./chunk-CGF4ITLZ.js";
import {
  Command
} from "./chunk-5LH7NKB4.js";
import {
  logger
} from "./chunk-H473MSWF.js";

// src/commands/dev.ts
import { spawn } from "node:child_process";
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
var __filename = fileURLToPath(import.meta.url);
var __dirname = path.dirname(__filename);
var serverProcess = null;
async function stopServer() {
  if (serverProcess) {
    logger.info("Stopping current server process...");
    const killed = serverProcess.kill("SIGTERM");
    if (!killed) {
      logger.warn("Failed to kill server process, trying force kill...");
      serverProcess.kill("SIGKILL");
    }
    serverProcess = null;
    await new Promise((resolve) => setTimeout(resolve, 500));
  }
}
async function startServer(args = []) {
  await stopServer();
  logger.info("Starting server...");
  const nodeExecutable = process.execPath;
  const scriptPath = process.argv[1];
  serverProcess = spawn(nodeExecutable, [scriptPath, "start", ...args], {
    stdio: "inherit",
    detached: false
    // We want to keep control of this process
  });
  serverProcess.on("exit", (code, signal) => {
    if (code !== null) {
      if (code !== 0) {
        logger.warn(`Server process exited with code ${code}`);
      } else {
        logger.info("Server process exited normally");
      }
    } else if (signal) {
      logger.info(`Server process was killed with signal ${signal}`);
    }
    serverProcess = null;
  });
  serverProcess.on("error", (err) => {
    logger.error(`Server process error: ${err.message}`);
    serverProcess = null;
  });
}
async function determineProjectType() {
  const cwd = process.cwd();
  const packageJsonPath = path.join(cwd, "package.json");
  let isProject = false;
  let isPlugin = false;
  if (fs.existsSync(packageJsonPath)) {
    try {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf-8"));
      logger.info(`Package name: ${packageJson.name}`);
      logger.info(
        `Package type check: ${JSON.stringify({
          "eliza.type": packageJson.eliza?.type,
          "name.includes(plugin)": packageJson.name?.includes("plugin-"),
          keywords: packageJson.keywords
        })}`
      );
      if (packageJson.name === "@elizaos/cli") {
        return { isProject: false, isPlugin: false };
      }
      if (packageJson.eliza?.type === "plugin" || packageJson.name?.includes("plugin-") || packageJson.keywords && Array.isArray(packageJson.keywords) && packageJson.keywords.some((k) => k === "elizaos-plugin" || k === "eliza-plugin")) {
        isPlugin = true;
        logger.info("Identified as a plugin package");
      }
      if (packageJson.eliza?.type === "project" || packageJson.name && (packageJson.name.includes("project-") || packageJson.name.includes("-org")) || packageJson.keywords && Array.isArray(packageJson.keywords) && packageJson.keywords.some(
        (k) => k === "elizaos-project" || k === "eliza-project"
      )) {
        isProject = true;
        logger.info("Identified as a project package");
      }
      if (!isProject && !isPlugin) {
        const indexPath = path.join(cwd, "src", "index.ts");
        if (fs.existsSync(indexPath)) {
          const indexContent = fs.readFileSync(indexPath, "utf-8");
          if (indexContent.includes("export const project") || indexContent.includes("export default") && indexContent.includes("Project")) {
            isProject = true;
            logger.info("Identified as a project by src/index.ts export");
          }
        }
      }
    } catch (error) {
      logger.warn(`Error parsing package.json: ${error}`);
    }
  }
  return { isProject, isPlugin };
}
async function watchDirectory(dir, onChange) {
  try {
    await execa("npm", ["list", "chokidar"], { stdio: "ignore", reject: false });
  } catch (error) {
    logger.info("Installing chokidar dependency for file watching...");
    try {
      await execa("npm", ["install", "chokidar", "--no-save"], { stdio: "inherit" });
    } catch (installError) {
      logger.error(`Failed to install chokidar: ${installError.message}`);
      return;
    }
  }
  try {
    const chokidar = await import("./esm-CDFO4YCA.js");
    const absoluteDir = path.resolve(dir);
    logger.info(`Setting up file watching for directory: ${absoluteDir}`);
    const srcDir = path.join(absoluteDir, "src");
    const dirToWatch = fs.existsSync(srcDir) ? srcDir : absoluteDir;
    logger.info(`Actually watching directory: ${dirToWatch}`);
    const watchOptions = {
      ignored: ["**/node_modules/**", "**/dist/**", "**/.git/**"],
      ignoreInitial: true,
      persistent: true,
      followSymlinks: false,
      depth: 99,
      // Set high depth to ensure we catch all nested files
      usePolling: false,
      // Only use polling if necessary
      interval: 1e3
      // Poll every second
    };
    logger.info(`Will watch files with extensions: .ts, .js, .tsx, .jsx`);
    const watcher = chokidar.watch(dirToWatch, {
      ...watchOptions
    });
    const findTsFiles = (dir2) => {
      let results = [];
      const entries = fs.readdirSync(dir2, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = path.join(dir2, entry.name);
        if (entry.isDirectory() && !entry.name.startsWith(".") && entry.name !== "node_modules" && entry.name !== "dist") {
          results = results.concat(findTsFiles(fullPath));
        } else if (entry.isFile() && (entry.name.endsWith(".ts") || entry.name.endsWith(".js") || entry.name.endsWith(".tsx") || entry.name.endsWith(".jsx"))) {
          results.push(path.relative(dirToWatch, fullPath));
        }
      }
      return results;
    };
    const tsFiles = findTsFiles(dirToWatch);
    logger.info(`Found ${tsFiles.length} TypeScript/JavaScript files in the watched directory`);
    if (tsFiles.length > 0) {
      logger.info(
        `Sample files: ${tsFiles.slice(0, 3).join(", ")}${tsFiles.length > 3 ? "..." : ""}`
      );
    }
    let debounceTimer = null;
    watcher.on("ready", () => {
      const watchedPaths = watcher.getWatched();
      const pathsCount = Object.keys(watchedPaths).length;
      logger.info(`Chokidar is watching ${pathsCount} directories`);
      if (pathsCount === 0) {
        logger.warn("No directories are being watched! File watching may not be working.");
        logger.info("Attempting to set up alternative file watching...");
        watcher.add(`${dirToWatch}/**/*.{ts,js,tsx,jsx}`);
      } else {
        logger.info(
          `Top-level watched directories: ${Object.keys(watchedPaths).slice(0, 5).join(", ")}${Object.keys(watchedPaths).length > 5 ? "..." : ""}`
        );
      }
      logger.success(`File watching initialized in: ${dirToWatch}`);
    });
    watcher.on("all", (event, filePath) => {
      if (!/\.(ts|js|tsx|jsx)$/.test(filePath)) {
        return;
      }
      logger.info(`File event: ${event} - ${filePath}`);
      if (debounceTimer) {
        clearTimeout(debounceTimer);
      }
      debounceTimer = setTimeout(() => {
        logger.info(`Triggering rebuild for file change: ${filePath}`);
        onChange();
        debounceTimer = null;
      }, 300);
    });
    watcher.on("error", (error) => {
      logger.error(`Chokidar watcher error: ${error}`);
    });
    process.on("SIGINT", () => {
      watcher.close().then(() => process.exit(0));
    });
    logger.success(`Watching for file changes in ${dirToWatch}`);
  } catch (error) {
    logger.error(`Error setting up file watcher: ${error.message}`);
    logger.error(error.stack);
  }
}
var dev = new Command().name("dev").description("Start the project or plugin in development mode and rebuild on file changes").option("-p, --port <port>", "Port to listen on", (val) => Number.parseInt(val)).option("-c, --configure", "Reconfigure services and AI models (skips using saved configuration)").option("--character <character>", "Path or URL to character file to use instead of default").option("--build", "Build the project before starting").action(async (options) => {
  try {
    const cwd = process.cwd();
    const { isProject, isPlugin } = await determineProjectType();
    const cliArgs = [];
    if (options.port) cliArgs.push("--port", options.port.toString());
    if (options.configure) cliArgs.push("--configure");
    if (options.character) cliArgs.push("--character", options.character);
    const rebuildAndRestart = async () => {
      try {
        await stopServer();
        logger.info("Rebuilding project after file change...");
        await buildProject(cwd, isPlugin);
        logger.success("Rebuild successful, restarting server...");
        await startServer(cliArgs);
      } catch (error) {
        logger.error(`Error during rebuild and restart: ${error.message}`);
        if (!serverProcess) {
          logger.info("Attempting to restart server regardless of build failure...");
          await startServer(cliArgs);
        }
      }
    };
    if (!isProject && !isPlugin) {
      logger.warn("Not in a recognized project or plugin directory. Running in standalone mode.");
    } else {
      logger.info(`Running in ${isProject ? "project" : "plugin"} mode`);
      logger.info("Building project...");
      try {
        await buildProject(cwd, isPlugin);
      } catch (error) {
        logger.error(`Initial build failed: ${error.message}`);
        logger.info("Continuing with dev mode anyway...");
      }
    }
    await startServer(cliArgs);
    if (isProject || isPlugin) {
      await watchDirectory(cwd, rebuildAndRestart);
      logger.success(`Dev mode is active! The server will restart when files change.`);
      logger.success("Press Ctrl+C to exit");
    } else {
      logger.debug("Running in standalone mode without file watching.");
    }
  } catch (error) {
    handleError(error);
  }
});

export {
  dev
};
