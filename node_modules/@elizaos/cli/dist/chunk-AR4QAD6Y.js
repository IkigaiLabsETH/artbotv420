
import { createRequire } from 'module';
const require = createRequire(import.meta.url);

import {
  AgentServer,
  jsonToCharacter,
  loadCharacterTryPath,
  promptForEnvVars,
  startAgent
} from "./chunk-TJFULA67.js";
import {
  character
} from "./chunk-O3UP5QHP.js";
import {
  buildProject
} from "./chunk-5GTCUWAK.js";
import {
  require_main
} from "./chunk-XDVWGVQZ.js";
import {
  Command
} from "./chunk-5LH7NKB4.js";
import {
  logger,
  v4_default
} from "./chunk-H473MSWF.js";
import {
  __toESM
} from "./chunk-567UPUC7.js";

// src/commands/test.ts
var dotenv = __toESM(require_main(), 1);
import * as fs2 from "node:fs";
import { existsSync as existsSync3 } from "node:fs";
import * as os from "node:os";
import path2 from "node:path";

// src/project.ts
import * as fs from "node:fs";
import path from "node:path";
function isPlugin(module) {
  if (module && typeof module === "object" && typeof module.name === "string" && typeof module.description === "string") {
    return true;
  }
  if (module && typeof module === "object" && module.default && typeof module.default === "object" && typeof module.default.name === "string" && typeof module.default.description === "string") {
    return true;
  }
  for (const key in module) {
    if (key !== "default" && module[key] && typeof module[key] === "object" && typeof module[key].name === "string" && typeof module[key].description === "string") {
      return true;
    }
  }
  return false;
}
function extractPlugin(module) {
  if (module && typeof module === "object" && typeof module.name === "string" && typeof module.description === "string") {
    return module;
  }
  if (module && typeof module === "object" && module.default && typeof module.default === "object" && typeof module.default.name === "string" && typeof module.default.description === "string") {
    return module.default;
  }
  for (const key in module) {
    if (key !== "default" && module[key] && typeof module[key] === "object" && typeof module[key].name === "string" && typeof module[key].description === "string") {
      return module[key];
    }
  }
  throw new Error("Could not extract plugin from module");
}
async function loadProject(dir) {
  try {
    const entryPoints = [
      path.join(dir, "src/index.ts"),
      path.join(dir, "src/index.js"),
      path.join(dir, "dist/index.js"),
      path.join(dir, "index.ts"),
      path.join(dir, "index.js")
    ];
    let projectModule = null;
    for (const entryPoint of entryPoints) {
      if (fs.existsSync(entryPoint)) {
        try {
          const importPath = path.resolve(entryPoint);
          projectModule = await import(importPath);
          logger.info(`Loaded project from ${entryPoint}`);
          const exportKeys = Object.keys(projectModule);
          logger.debug(`Module exports: ${exportKeys.join(", ")}`);
          if (exportKeys.includes("default")) {
            logger.debug(`Default export type: ${typeof projectModule.default}`);
            if (typeof projectModule.default === "object" && projectModule.default !== null) {
              logger.debug(`Default export keys: ${Object.keys(projectModule.default).join(", ")}`);
            }
          }
          break;
        } catch (error) {
          logger.warn(`Failed to import project from ${entryPoint}:`, error);
        }
      }
    }
    if (!projectModule) {
      throw new Error("Could not find project entry point");
    }
    const moduleIsPlugin = isPlugin(projectModule);
    logger.debug(`Is this a plugin? ${moduleIsPlugin}`);
    if (moduleIsPlugin) {
      logger.info("Detected plugin module instead of project");
      try {
        const plugin = extractPlugin(projectModule);
        logger.debug(`Found plugin: ${plugin.name} - ${plugin.description}`);
        logger.debug(`Plugin has the following properties: ${Object.keys(plugin).join(", ")}`);
        const completePlugin = {
          name: plugin.name || "unknown-plugin",
          description: plugin.description || "No description",
          init: plugin.init || (async (config2, runtime) => {
            logger.info(`Dummy init for plugin: ${plugin.name}`);
          }),
          // Copy all other properties from the original plugin
          ...plugin
        };
        const testCharacter = {
          ...character,
          id: v4_default(),
          name: "Eliza (Test Mode)",
          system: `${character.system} Testing the plugin: ${completePlugin.name}.`
        };
        logger.info(`Using Eliza character as test agent for plugin: ${completePlugin.name}`);
        const testAgent = {
          character: testCharacter,
          plugins: [completePlugin],
          // Only include the plugin being tested
          init: async (runtime) => {
            logger.info(`Initializing Eliza test agent for plugin: ${completePlugin.name}`);
          }
        };
        return {
          agents: [testAgent],
          dir,
          isPlugin: true,
          pluginModule: completePlugin
        };
      } catch (error) {
        logger.error("Error extracting plugin from module:", error);
        throw error;
      }
    }
    const agents = [];
    if (projectModule.default && typeof projectModule.default === "object" && Array.isArray(projectModule.default.agents)) {
      agents.push(...projectModule.default.agents);
      logger.debug(`Found ${agents.length} agents in default export's agents array`);
    } else {
      for (const [key, value] of Object.entries(projectModule)) {
        if (key === "default" && value && typeof value === "object") {
          if (value.character && value.init) {
            agents.push(value);
            logger.debug(`Found agent in default export (single agent)`);
          }
        } else if (value && typeof value === "object" && value.character && value.init) {
          agents.push(value);
          logger.debug(`Found agent in named export: ${key}`);
        }
      }
    }
    if (agents.length === 0) {
      throw new Error("No agents found in project");
    }
    const project = {
      agents,
      dir
    };
    return project;
  } catch (error) {
    logger.error("Error loading project:", error);
    throw error;
  }
}

// src/testRunner.ts
var TestRunner = class {
  runtime;
  projectAgent;
  stats;
  isDirectPluginTest;
  constructor(runtime, projectAgent) {
    this.runtime = runtime;
    this.projectAgent = projectAgent;
    this.stats = {
      total: 0,
      passed: 0,
      failed: 0,
      skipped: 0
    };
    if (projectAgent?.plugins?.length === 1 && (projectAgent.character.name.includes(`Test Agent for ${projectAgent.plugins[0].name}`) || projectAgent.character.name.toLowerCase().includes("test") && projectAgent.character.name.toLowerCase().includes(projectAgent.plugins[0].name.toLowerCase())) || // Alternatively, if we were launched from within a plugin directory, consider it a direct test
    process.env.ELIZA_TESTING_PLUGIN === "true") {
      this.isDirectPluginTest = true;
      logger.debug("This is a direct plugin test - will only run tests for this plugin");
    } else {
      this.isDirectPluginTest = false;
    }
  }
  /**
   * Runs a test suite
   * @param suite The test suite to run
   */
  async runTestSuite(suite) {
    logger.info(`
Running test suite: ${suite.name}`);
    for (const test2 of suite.tests) {
      this.stats.total++;
      try {
        logger.info(`  Running test: ${test2.name}`);
        await test2.fn(this.runtime);
        this.stats.passed++;
        logger.success(`  \u2713 ${test2.name}`);
      } catch (error) {
        this.stats.failed++;
        logger.error(`  \u2717 ${test2.name}`);
        logger.error(`    ${error.message}`);
      }
    }
  }
  /**
   * Runs project agent tests
   */
  async runProjectTests(options) {
    if (!this.projectAgent?.tests || options.skipProjectTests || this.isDirectPluginTest) {
      if (this.isDirectPluginTest) {
        logger.info("Skipping project tests when directly testing a plugin");
      }
      return;
    }
    logger.info("\nRunning project tests...");
    const testSuites = Array.isArray(this.projectAgent.tests) ? this.projectAgent.tests : [this.projectAgent.tests];
    for (const suite of testSuites) {
      if (!suite) {
        continue;
      }
      if (options.filter && !suite.name.includes(options.filter)) {
        this.stats.skipped++;
        continue;
      }
      await this.runTestSuite(suite);
    }
  }
  /**
   * Runs plugin tests
   */
  async runPluginTests(options) {
    if (options.skipPlugins && !this.isDirectPluginTest) {
      return;
    }
    if (this.isDirectPluginTest) {
      logger.info("\nRunning plugin tests...");
      const plugin = this.projectAgent?.plugins?.[0];
      if (!plugin || !plugin.tests) {
        logger.warn(`No tests found for this plugin (${plugin?.name || "unknown plugin"})`);
        logger.info(
          "To add tests to your plugin, include a 'tests' property with an array of test suites."
        );
        logger.info("Example:");
        logger.info(`
export const myPlugin = {
  name: "my-plugin",
  description: "My awesome plugin",
  
  // ... other plugin properties ...
  
  tests: [
    {
      name: "Basic Tests",
      tests: [
        {
          name: "should do something",
          fn: async (runtime) => {
            // Test code here
          }
        }
      ]
    }
  ]
};
`);
        return;
      }
      logger.info(`Found test suites for plugin: ${plugin.name}`);
      const testSuites = Array.isArray(plugin.tests) ? plugin.tests : [plugin.tests];
      for (const suite of testSuites) {
        if (!suite) {
          continue;
        }
        if (options.filter && !suite.name.includes(options.filter)) {
          logger.info(
            `Skipping test suite "${suite.name}" because it doesn't match filter "${options.filter}"`
          );
          this.stats.skipped++;
          continue;
        }
        await this.runTestSuite(suite);
      }
    } else {
      logger.info("\nRunning project plugin tests...");
      const plugins = this.projectAgent?.plugins || [];
      if (plugins.length === 0) {
        logger.info("No plugins defined directly in project to test");
        return;
      }
      logger.info(`Found ${plugins.length} plugins defined in project`);
      for (const plugin of plugins) {
        try {
          if (!plugin) {
            continue;
          }
          logger.info(`Testing plugin: ${plugin.name || "unnamed plugin"}`);
          const pluginTests = plugin.tests;
          if (!pluginTests) {
            logger.info(`No tests found for plugin: ${plugin.name || "unnamed plugin"}`);
            continue;
          }
          const testSuites = Array.isArray(pluginTests) ? pluginTests : [pluginTests];
          for (const suite of testSuites) {
            if (!suite) {
              continue;
            }
            if (options.filter && !suite.name.includes(options.filter)) {
              logger.info(`Skipping test suite "${suite.name}" (doesn't match filter)`);
              this.stats.skipped++;
              continue;
            }
            await this.runTestSuite(suite);
          }
        } catch (error) {
          logger.error(`Error running tests for plugin ${plugin.name}:`, error);
          this.stats.failed++;
        }
      }
    }
  }
  /**
   * Runs all tests in the project
   * @param options Test options
   */
  async runTests(options = {}) {
    await this.runProjectTests(options);
    await this.runPluginTests(options);
    logger.info(
      `
Test Summary: ${this.stats.passed} passed, ${this.stats.failed} failed, ${this.stats.skipped} skipped`
    );
    return this.stats;
  }
};

// src/commands/test.ts
function checkIfLikelyPluginDir(dir) {
  return dir.includes("plugin") || existsSync3(path2.join(dir, "src/plugin.ts")) || existsSync3(path2.join(dir, "src/index.ts")) && !existsSync3(path2.join(dir, "src/agent.ts"));
}
var runAgentTests = async (options) => {
  if (options && !options.skipBuild) {
    try {
      const cwd = process.cwd();
      const isPlugin2 = options.plugin ? true : checkIfLikelyPluginDir(cwd);
      logger.info(`Building ${isPlugin2 ? "plugin" : "project"}...`);
      await buildProject(cwd, isPlugin2);
      logger.info(`Build completed successfully`);
    } catch (buildError) {
      logger.error(`Build error: ${buildError}`);
      logger.warn(`Attempting to continue with tests despite build error`);
    }
  }
  try {
    const runtimes = [];
    const projectAgents = [];
    const homeDir = os.homedir();
    const elizaDir = path2.join(homeDir, ".eliza");
    const elizaDbDir = path2.join(elizaDir, "db");
    const envFilePath = path2.join(elizaDir, ".env");
    logger.info("Setting up environment...");
    logger.info(`Home directory: ${homeDir}`);
    logger.info(`Eliza directory: ${elizaDir}`);
    logger.info(`Database directory: ${elizaDbDir}`);
    logger.info(`Environment file: ${envFilePath}`);
    if (!fs2.existsSync(elizaDir)) {
      logger.info(`Creating directory: ${elizaDir}`);
      fs2.mkdirSync(elizaDir, { recursive: true });
      logger.info(`Created directory: ${elizaDir}`);
    }
    if (!fs2.existsSync(elizaDbDir)) {
      logger.info(`Creating database directory: ${elizaDbDir}`);
      fs2.mkdirSync(elizaDbDir, { recursive: true });
      logger.info(`Created database directory: ${elizaDbDir}`);
    }
    process.env.PGLITE_DATA_DIR = elizaDbDir;
    logger.info(`Using database directory: ${elizaDbDir}`);
    if (fs2.existsSync(envFilePath)) {
      logger.info(`Loading environment variables from: ${envFilePath}`);
      dotenv.config({ path: envFilePath });
      logger.info("Environment variables loaded");
    } else {
      logger.warn(`Environment file not found: ${envFilePath}`);
    }
    try {
      logger.info("Configuring database...");
      await promptForEnvVars("pglite");
      logger.info("Database configuration completed");
    } catch (error) {
      logger.error("Error configuring database:", error);
      if (error instanceof Error) {
        logger.error("Error details:", error.message);
        logger.error("Stack trace:", error.stack);
      }
      throw error;
    }
    const postgresUrl = process.env.POSTGRES_URL;
    logger.info(`PostgreSQL URL: ${postgresUrl ? "found" : "not found"}`);
    logger.info("Creating server instance...");
    const server = new AgentServer({
      dataDir: elizaDbDir,
      postgresUrl
    });
    logger.info("Server instance created");
    logger.info("Waiting for database initialization...");
    try {
      await new Promise((resolve, reject) => {
        let initializationAttempts = 0;
        const maxAttempts = 5;
        const checkInterval = setInterval(async () => {
          try {
            if (server.database?.isInitialized) {
              clearInterval(checkInterval);
              resolve();
              return;
            }
            initializationAttempts++;
            try {
              await server.database?.init();
              clearInterval(checkInterval);
              resolve();
            } catch (initError) {
              logger.warn(
                `Database initialization attempt ${initializationAttempts}/${maxAttempts} failed:`,
                initError
              );
              if (initializationAttempts >= maxAttempts) {
                if (server.database?.connection) {
                  logger.warn(
                    "Max initialization attempts reached, but database connection exists. Proceeding anyway."
                  );
                  clearInterval(checkInterval);
                  resolve();
                } else {
                  clearInterval(checkInterval);
                  reject(new Error(`Database initialization failed after ${maxAttempts} attempts`));
                }
              }
            }
          } catch (error) {
            logger.error("Error during database initialization check:", error);
            if (error instanceof Error) {
              logger.error("Error details:", error.message);
              logger.error("Stack trace:", error.stack);
            }
            clearInterval(checkInterval);
            reject(error);
          }
        }, 1e3);
        setTimeout(() => {
          clearInterval(checkInterval);
          if (server.database?.connection) {
            logger.warn(
              "Database initialization timeout, but connection exists. Proceeding anyway."
            );
            resolve();
          } else {
            reject(new Error("Database initialization timed out after 30 seconds"));
          }
        }, 3e4);
      });
      logger.info("Database initialized successfully");
    } catch (error) {
      logger.error("Failed to initialize database:", error);
      if (error instanceof Error) {
        logger.error("Error details:", error.message);
        logger.error("Stack trace:", error.stack);
      }
      throw error;
    }
    logger.info("Setting up server properties...");
    server.startAgent = async (character2) => {
      logger.info(`Starting agent for character ${character2.name}`);
      return startAgent(character2, server);
    };
    server.loadCharacterTryPath = loadCharacterTryPath;
    server.jsonToCharacter = jsonToCharacter;
    logger.info("Server properties set up");
    const serverPort = options.port || Number.parseInt(process.env.SERVER_PORT || "3000");
    let project;
    try {
      logger.info("Attempting to load project or plugin...");
      project = await loadProject(process.cwd());
      if (project.isPlugin) {
        logger.info(`Plugin loaded successfully: ${project.pluginModule?.name}`);
      } else {
        logger.info("Project loaded successfully");
      }
      if (!project || !project.agents || project.agents.length === 0) {
        throw new Error("No agents found in project configuration");
      }
      logger.info(
        `Found ${project.agents.length} agents in ${project.isPlugin ? "plugin" : "project"} configuration`
      );
    } catch (error) {
      logger.error("Error loading project/plugin:", error);
      logger.error("Tests cannot run without a valid project or plugin. Exiting.");
      if (error instanceof Error) {
        if (error.message.includes("Could not find project entry point")) {
          logger.error("No Eliza project or plugin found in current directory.");
          logger.error("Tests can only run in a valid Eliza project or plugin directory.");
        }
        logger.error("Error details:", error.message);
      }
      process.exit(1);
    }
    logger.info("Starting server...");
    try {
      await server.start(serverPort);
      logger.info("Server started successfully");
    } catch (error) {
      logger.error("Error starting server:", error);
      if (error instanceof Error) {
        logger.error("Error details:", error.message);
        logger.error("Stack trace:", error.stack);
      }
      throw error;
    }
    try {
      logger.info(
        `Found ${project.agents.length} agents in ${project.isPlugin ? "plugin" : "project"}`
      );
      if (project.isPlugin || project.agents.length === 0) {
        process.env.ELIZA_TESTING_PLUGIN = "true";
        logger.info("Using default Eliza character as test agent");
        try {
          const { character: defaultElizaCharacter } = await import("./eliza-GWTDNYUZ.js");
          const pluginsToTest = [project.pluginModule];
          logger.info(`Starting test agent with plugin: ${project.pluginModule?.name}`);
          logger.debug(
            `Using default character with plugins: ${defaultElizaCharacter.plugins ? defaultElizaCharacter.plugins.join(", ") : "none"}`
          );
          logger.info(
            "Plugin test mode: Using default character's plugins plus the plugin being tested"
          );
          const runtime = await startAgent(
            defaultElizaCharacter,
            server,
            void 0,
            pluginsToTest,
            {
              isPluginTestMode: true
            }
          );
          runtimes.push(runtime);
          projectAgents.push({
            character: defaultElizaCharacter,
            plugins: pluginsToTest
          });
          logger.info("Default test agent started successfully");
        } catch (pluginError) {
          logger.error(`Error starting plugin test agent: ${pluginError}`);
          throw pluginError;
        }
      } else {
        for (const agent of project.agents) {
          try {
            const originalCharacter = { ...agent.character };
            logger.debug(`Starting agent: ${originalCharacter.name}`);
            const runtime = await startAgent(
              originalCharacter,
              server,
              agent.init,
              agent.plugins || []
            );
            runtimes.push(runtime);
            projectAgents.push(agent);
            await new Promise((resolve) => setTimeout(resolve, 1e3));
          } catch (agentError) {
            logger.error(`Error starting agent ${agent.character.name}:`, agentError);
            if (agentError instanceof Error) {
              logger.error("Error details:", agentError.message);
              logger.error("Stack trace:", agentError.stack);
            }
            logger.warn(`Skipping agent ${agent.character.name} due to startup error`);
          }
        }
      }
      if (runtimes.length === 0) {
        throw new Error("Failed to start any agents from project");
      }
      logger.debug(`Successfully started ${runtimes.length} agents for testing`);
      let totalFailed = 0;
      for (let i = 0; i < runtimes.length; i++) {
        const runtime = runtimes[i];
        const projectAgent = projectAgents[i];
        if (project.isPlugin) {
          logger.debug(`Running tests for plugin: ${project.pluginModule?.name}`);
        } else {
          logger.debug(`Running tests for agent: ${runtime.character.name}`);
        }
        const testRunner = new TestRunner(runtime, projectAgent);
        const skipPlugins = project.isPlugin ? true : options.skipPlugins;
        const results = await testRunner.runTests({
          filter: options.plugin,
          skipPlugins,
          skipProjectTests: options.skipProjectTests
        });
        totalFailed += results.failed;
      }
      await server.stop();
      process.exit(totalFailed > 0 ? 1 : 0);
    } catch (error) {
      logger.error("Error running tests:", error);
      if (error instanceof Error) {
        logger.error("Error details:", error.message);
        logger.error("Stack trace:", error.stack);
      }
      await server.stop();
      throw error;
    }
  } catch (error) {
    logger.error("Error in runAgentTests:", error);
    if (error instanceof Error) {
      logger.error("Error details:", error.message);
      logger.error("Stack trace:", error.stack);
    } else {
      logger.error("Unknown error type:", typeof error);
      logger.error("Error value:", error);
      try {
        logger.error("Stringified error:", JSON.stringify(error, null, 2));
      } catch (e) {
        logger.error("Could not stringify error:", e);
      }
    }
    throw error;
  }
};
var test = new Command().name("test").description("Run tests for Eliza agent plugins").option("-p, --port <port>", "Port to listen on", (val) => Number.parseInt(val)).option("-P, --plugin <name>", "Name of plugin to test").option("--skip-plugins", "Skip plugin tests").option("--skip-project-tests", "Skip project tests").option("--skip-build", "Skip building before running tests").action(async (options) => {
  logger.info("Starting test command...");
  logger.info("Command options:", options);
  try {
    logger.info("Running agent tests...");
    await runAgentTests(options);
  } catch (error) {
    logger.error("Error running tests:", error);
    if (error instanceof Error) {
      logger.error("Error details:", error.message);
      logger.error("Stack trace:", error.stack);
    } else {
      logger.error("Unknown error type:", typeof error);
      logger.error("Error value:", error);
      try {
        logger.error("Stringified error:", JSON.stringify(error, null, 2));
      } catch (e) {
        logger.error("Could not stringify error:", e);
      }
    }
    process.exit(1);
  }
});
function registerCommand(cli) {
  return cli.addCommand(test);
}

export {
  test,
  registerCommand
};
