
import { createRequire } from 'module';
const require = createRequire(import.meta.url);

import {
  publishToGitHub,
  testPublishToGitHub,
  testPublishToNpm
} from "./chunk-M6QKWXHS.js";
import {
  require_prompts
} from "./chunk-LRSU7IN6.js";
import {
  getGitHubCredentials,
  getRegistrySettings,
  initializeDataDir,
  saveRegistrySettings,
  validateDataDir
} from "./chunk-VI5W7VMD.js";
import {
  execa
} from "./chunk-LIA2BGYJ.js";
import {
  handleError
} from "./chunk-CGF4ITLZ.js";
import {
  Command
} from "./chunk-5LH7NKB4.js";
import {
  logger
} from "./chunk-H473MSWF.js";
import {
  __toESM
} from "./chunk-567UPUC7.js";

// src/commands/plugin.ts
import { promises as fs, existsSync } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
var import_prompts = __toESM(require_prompts(), 1);
var plugin = new Command().name("plugin").description("Manage ElizaOS plugins, including publishing");
plugin.command("publish").description("publish a plugin to a registry").option("-r, --registry <registry>", "target registry", "elizaOS/registry").option("-n, --npm", "publish to npm instead of GitHub", false).option("-t, --test", "test publish process without making changes", false).option(
  "-p, --platform <platform>",
  "specify platform compatibility (node, browser, universal)",
  "universal"
).action(async (opts) => {
  try {
    const cwd = process.cwd();
    const isValid = await validateDataDir();
    if (!isValid) {
      logger.info("\nGitHub credentials required for publishing.");
      logger.info("You'll need a GitHub Personal Access Token with these scopes:");
      logger.info("  * repo (for repository access)");
      logger.info("  * read:org (for organization access)");
      logger.info("  * workflow (for workflow access)\n");
      await initializeDataDir();
      const credentials2 = await getGitHubCredentials();
      if (!credentials2) {
        logger.error("GitHub credentials setup cancelled.");
        process.exit(1);
      }
      const revalidated = await validateDataDir();
      if (!revalidated) {
        logger.error("Failed to validate credentials after saving.");
        process.exit(1);
      }
    }
    const packageJsonPath = path.join(cwd, "package.json");
    if (!existsSync(packageJsonPath)) {
      logger.error("No package.json found in current directory.");
      process.exit(1);
    }
    const packageJsonContent = await fs.readFile(packageJsonPath, "utf-8");
    const packageJson = JSON.parse(packageJsonContent);
    if (!packageJson.name || !packageJson.version) {
      logger.error("Invalid package.json: missing name or version.");
      process.exit(1);
    }
    const validPlatforms = ["node", "browser", "universal"];
    if (opts.platform && !validPlatforms.includes(opts.platform)) {
      logger.error(
        `Invalid platform: ${opts.platform}. Valid options are: ${validPlatforms.join(", ")}`
      );
      process.exit(1);
    }
    if (opts.platform) {
      packageJson.platform = opts.platform;
    }
    if (!packageJson.name.includes("plugin-")) {
      logger.warn(
        "This doesn't appear to be an ElizaOS plugin. Package name should include 'plugin-'."
      );
      const { proceed } = await (0, import_prompts.default)({
        type: "confirm",
        name: "proceed",
        message: "Proceed anyway?",
        initial: false
      });
      if (!proceed) {
        process.exit(0);
      }
    }
    const cliPackageJsonPath = path.resolve(
      path.dirname(fileURLToPath(import.meta.url)),
      "../package.json"
    );
    let cliVersion = "0.0.0";
    try {
      const cliPackageJsonContent = await fs.readFile(cliPackageJsonPath, "utf-8");
      const cliPackageJson = JSON.parse(cliPackageJsonContent);
      cliVersion = cliPackageJson.version || "0.0.0";
    } catch (error) {
      logger.warn("Could not determine CLI version, using 0.0.0");
    }
    let credentials = await getGitHubCredentials();
    if (!credentials) {
      logger.info("\nGitHub credentials required for publishing.");
      logger.info("Please enter your GitHub credentials:\n");
      await new Promise((resolve) => setTimeout(resolve, 10));
      const newCredentials = await getGitHubCredentials();
      if (!newCredentials) {
        process.exit(1);
      }
      credentials = newCredentials;
    }
    const settings = await getRegistrySettings();
    settings.defaultRegistry = opts.registry;
    settings.publishConfig = {
      registry: opts.registry,
      username: credentials.username,
      useNpm: opts.npm,
      platform: opts.platform
    };
    await saveRegistrySettings(settings);
    if (opts.test) {
      logger.info("Running publish tests...");
      if (opts.npm) {
        logger.info("\nTesting npm publishing:");
        const npmTestSuccess = await testPublishToNpm(cwd);
        if (!npmTestSuccess) {
          logger.error("npm publishing test failed");
          process.exit(1);
        }
      }
      logger.info("\nTesting GitHub publishing:");
      const githubTestSuccess = await testPublishToGitHub(cwd, packageJson, credentials.username);
      if (!githubTestSuccess) {
        logger.error("GitHub publishing test failed");
        process.exit(1);
      }
      logger.success("All tests passed successfully!");
      return;
    }
    if (opts.npm) {
      logger.info("Publishing to npm...");
      try {
        await execa("npm", ["whoami"], { stdio: "inherit" });
      } catch (error) {
        logger.error("Not logged in to npm. Please run 'npm login' first.");
        process.exit(1);
      }
      logger.info("Building package...");
      await execa("npm", ["run", "build"], { cwd, stdio: "inherit" });
      logger.info("Publishing to npm...");
      await execa("npm", ["publish"], { cwd, stdio: "inherit" });
      logger.success(`Successfully published ${packageJson.name}@${packageJson.version} to npm`);
      return;
    }
    const success = await publishToGitHub(
      cwd,
      packageJson,
      cliVersion,
      credentials.username,
      false
    );
    if (!success) {
      process.exit(1);
    }
    logger.success(`Successfully published ${packageJson.name}@${packageJson.version}`);
  } catch (error) {
    handleError(error);
  }
});

export {
  plugin
};
