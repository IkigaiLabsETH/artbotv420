
import { createRequire } from 'module';
const require = createRequire(import.meta.url);

import {
  displayBanner,
  getElizaDirectories,
  promptAndStorePostgresUrl,
  setupPgLite
} from "./chunk-5ICVFLOJ.js";
import {
  runBunCommand
} from "./chunk-JE3WCXNS.js";
import {
  buildProject
} from "./chunk-5GTCUWAK.js";
import {
  base_exports
} from "./chunk-XKA2ZD3D.js";
import {
  require_prompts
} from "./chunk-LRSU7IN6.js";
import {
  execa
} from "./chunk-LIA2BGYJ.js";
import {
  handleError
} from "./chunk-CGF4ITLZ.js";
import {
  Command
} from "./chunk-5LH7NKB4.js";
import {
  logger
} from "./chunk-H473MSWF.js";
import {
  __require,
  __toESM
} from "./chunk-567UPUC7.js";

// src/utils/copy-template.ts
import { promises as fs, existsSync } from "node:fs";
import path from "node:path";
async function copyDir(src, dest, exclude = []) {
  await fs.mkdir(dest, { recursive: true });
  const entries = await fs.readdir(src, { withFileTypes: true });
  for (const entry of entries) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);
    if (exclude.includes(entry.name)) {
      continue;
    }
    if (entry.name === "node_modules" || entry.name === ".git" || entry.name === "cache" || entry.name === "data" || entry.name === "generatedImages" || entry.name === ".turbo") {
      continue;
    }
    if (entry.isDirectory()) {
      await copyDir(srcPath, destPath, exclude);
    } else {
      await fs.copyFile(srcPath, destPath);
    }
  }
}
async function copyTemplate(templateType, targetDir, name) {
  let templateDir;
  if (process.env.NODE_ENV === "development") {
    templateDir = path.resolve(
      process.cwd(),
      "packages",
      templateType === "project" ? "project-starter" : "plugin-starter"
    );
  } else {
    templateDir = path.resolve(
      path.dirname(__require.resolve("@elizaos/cli/package.json")),
      "templates",
      templateType === "project" ? "project-starter" : "plugin-starter"
    );
  }
  logger.info(`Copying ${templateType} template from ${templateDir} to ${targetDir}`);
  await copyDir(templateDir, targetDir);
  const packageJsonPath = path.join(targetDir, "package.json");
  try {
    const cliPackageJsonPath = path.resolve(
      path.dirname(__require.resolve("@elizaos/cli/package.json")),
      "package.json"
    );
    const cliPackageJson = JSON.parse(await fs.readFile(cliPackageJsonPath, "utf8"));
    const cliPackageVersion = cliPackageJson.version;
    const packageJson = JSON.parse(await fs.readFile(packageJsonPath, "utf8"));
    packageJson.name = name;
    if (packageJson.dependencies) {
      for (const depName of Object.keys(packageJson.dependencies)) {
        if (depName.startsWith("@elizaos/")) {
          logger.info(`Setting ${depName} to use latest version dynamically`);
          packageJson.dependencies[depName] = cliPackageVersion;
        }
      }
    }
    if (packageJson.devDependencies) {
      for (const depName of Object.keys(packageJson.devDependencies)) {
        if (depName.startsWith("@elizaos/")) {
          logger.info(`Setting dev dependency ${depName} to use version ${cliPackageVersion}`);
          packageJson.devDependencies[depName] = cliPackageVersion;
        }
      }
    }
    await fs.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2));
    logger.success("Updated package.json with project name and latest dependencies");
  } catch (error) {
    logger.error(`Error updating package.json: ${error}`);
  }
  logger.success(`${templateType} template copied successfully`);
}

// src/commands/create.ts
var import_prompts = __toESM(require_prompts(), 1);
import { existsSync as existsSync2, readFileSync } from "node:fs";
import fs2 from "node:fs/promises";
import path2 from "node:path";
import { z } from "zod";
var initOptionsSchema = z.object({
  dir: z.string().default("."),
  yes: z.boolean().default(false),
  type: z.enum(["project", "plugin"]).default("project")
});
async function getLocalAvailableDatabases() {
  return [
    "pglite",
    "postgres"
    // "sqlite",
    // "supabase"
  ];
}
async function installDependencies(targetDir) {
  logger.info("Installing dependencies...");
  try {
    await execa("npm", ["install", "-g", "bun"], {
      stdio: "inherit"
    });
  } catch (_error) {
    logger.warn("Failed to install bun globally. Continuing with installation...");
  }
  try {
    await runBunCommand(["install", "--no-optional"], targetDir);
    logger.success("Installed base dependencies");
  } catch (error) {
    logger.warn("Failed to install dependencies automatically. Please run 'bun install' manually.");
  }
}
var create = new Command().name("create").description("Initialize a new project or plugin").option("-d, --dir <dir>", "installation directory", ".").option("-y, --yes", "skip confirmation", false).option("-t, --type <type>", "type of template to use (project or plugin)", "").argument("[name]", "name for the project or plugin").action(async (name, opts) => {
  displayBanner();
  try {
    const initialOptions = {
      dir: opts.dir || ".",
      yes: opts.yes || false,
      type: opts.type || ""
    };
    let projectType = initialOptions.type;
    if (!projectType) {
      const { type } = await (0, import_prompts.default)({
        type: "select",
        name: "type",
        message: "What would you like to create?",
        choices: [
          { title: "Project - Contains agents and plugins", value: "project" },
          {
            title: "Plugin - Can be added to the registry and installed by others",
            value: "plugin"
          }
        ],
        initial: 0
      });
      if (!type) {
        process.exit(0);
      }
      projectType = type;
    } else {
      if (!["project", "plugin"].includes(projectType)) {
        logger.error(`Invalid type: ${projectType}. Must be either 'project' or 'plugin'`);
        process.exit(1);
      }
    }
    const options = initOptionsSchema.parse({
      ...initialOptions,
      type: projectType
    });
    const envPath = path2.join(process.cwd(), ".env");
    let currentPath = envPath;
    let depth = 0;
    const maxDepth = 10;
    let postgresUrl = null;
    while (depth < maxDepth && currentPath.includes(path2.sep)) {
      if (existsSync2(currentPath)) {
        const env = readFileSync(currentPath, "utf8");
        const envVars = env.split("\n").filter((line) => line.trim() !== "");
        const postgresUrlLine = envVars.find((line) => line.startsWith("POSTGRES_URL="));
        if (postgresUrlLine) {
          postgresUrl = postgresUrlLine.split("=")[1].trim();
          break;
        }
      }
      const currentDir = path2.dirname(currentPath);
      const parentDir = path2.dirname(currentDir);
      currentPath = path2.join(parentDir, ".env");
      depth++;
    }
    let projectName = name;
    if (!projectName) {
      const { nameResponse } = await (0, import_prompts.default)({
        type: "text",
        name: "nameResponse",
        message: `What would you like to name your ${options.type}?`,
        validate: (value) => value.length > 0 || `${options.type} name is required`
      });
      if (!nameResponse) {
        process.exit(0);
      }
      projectName = nameResponse;
    }
    const targetDir = path2.resolve(options.dir, projectName);
    if (!existsSync2(targetDir)) {
      await fs2.mkdir(targetDir, { recursive: true });
    } else {
      const files = await fs2.readdir(targetDir);
      const isEmpty = files.length === 0 || files.every((f) => f.startsWith("."));
      if (!isEmpty && !options.yes) {
        const { proceed } = await (0, import_prompts.default)({
          type: "confirm",
          name: "proceed",
          message: "Directory is not empty. Continue anyway?",
          initial: false
        });
        if (!proceed) {
          process.exit(0);
        }
      }
    }
    if (options.type === "plugin") {
      const pluginName = projectName.startsWith("@elizaos/plugin-") ? projectName : `@elizaos/plugin-${projectName}`;
      await copyTemplate("plugin", targetDir, pluginName);
      logger.info("Installing dependencies...");
      try {
        await runBunCommand(["install", "--no-optional"], targetDir);
        logger.success("Dependencies installed successfully!");
        await buildProject(targetDir, true);
      } catch (_error) {
        logger.warn(
          "Failed to install dependencies automatically. Please run 'bun install' manually."
        );
      }
      logger.success("Plugin initialized successfully!");
      const cdPath2 = options.dir === "." ? projectName : path2.relative(process.cwd(), targetDir);
      logger.info(`
Your plugin is ready! Here's what you can do next:
1. \`cd ${cdPath2}\` to change into your plugin directory
2. \`${base_exports.cyan("npx elizaos start")}\` to start development
3. \`${base_exports.cyan("npx elizaos test")}\` to test your plugin
4. \`${base_exports.cyan("npx elizaos publish")}\` to publish your plugin to the registry`);
      process.stdout.write(`\x1B]1337;CurrentDir=${targetDir}\x07`);
      return;
    }
    const availableDatabases = await getLocalAvailableDatabases();
    const { database } = await (0, import_prompts.default)({
      type: "select",
      name: "database",
      message: "Select your database:",
      choices: availableDatabases.sort((a, b) => a.localeCompare(b)).map((db) => ({
        title: db,
        value: db
      })),
      initial: availableDatabases.indexOf("pglite")
    });
    if (!database) {
      logger.error("No database selected");
      process.exit(1);
    }
    await copyTemplate("project", targetDir, projectName);
    const { elizaDbDir, envFilePath } = getElizaDirectories();
    if (database === "pglite") {
      await setupPgLite(elizaDbDir, envFilePath);
      logger.debug(`Using PGLite database directory: ${elizaDbDir}`);
    } else if (database === "postgres" && !postgresUrl) {
      postgresUrl = await promptAndStorePostgresUrl(envFilePath);
    }
    const srcDir = path2.join(targetDir, "src");
    if (!existsSync2(srcDir)) {
      await fs2.mkdir(srcDir);
    }
    await fs2.mkdir(path2.join(targetDir, "knowledge"), { recursive: true });
    await installDependencies(targetDir);
    await buildProject(targetDir);
    logger.success("Project initialized successfully!");
    const cdPath = options.dir === "." ? projectName : path2.relative(process.cwd(), targetDir);
    logger.info(`
Your project is ready! Here's what you can do next:
1. \`cd ${cdPath}\` to change into your project directory
2. Run \`npx elizaos start\` to start your project
3. Visit \`http://localhost:3000\` (or your custom port) to view your project in the browser`);
    process.stdout.write(`\x1B]1337;CurrentDir=${targetDir}\x07`);
    process.exit(0);
  } catch (error) {
    handleError(error);
  }
});

export {
  create
};
