var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// ../../node_modules/dedent/dist/dedent.js
var require_dedent = __commonJS({
  "../../node_modules/dedent/dist/dedent.js"(exports, module) {
    "use strict";
    function dedent3(strings) {
      var raw2 = void 0;
      if (typeof strings === "string") {
        raw2 = [strings];
      } else {
        raw2 = strings.raw;
      }
      var result = "";
      for (var i = 0; i < raw2.length; i++) {
        result += raw2[i].replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`");
        if (i < (arguments.length <= 1 ? 0 : arguments.length - 1)) {
          result += arguments.length <= i + 1 ? void 0 : arguments[i + 1];
        }
      }
      var lines = result.split("\n");
      var mindent = null;
      lines.forEach(function(l) {
        var m = l.match(/^(\s+)\S+/);
        if (m) {
          var indent = m[1].length;
          if (!mindent) {
            mindent = indent;
          } else {
            mindent = Math.min(mindent, indent);
          }
        }
      });
      if (mindent !== null) {
        result = lines.map(function(l) {
          return l[0] === " " ? l.slice(mindent) : l;
        }).join("\n");
      }
      result = result.trim();
      return result.replace(/\\n/g, "\n");
    }
    if (typeof module !== "undefined") {
      module.exports = dedent3;
    }
  }
});

// src/types.ts
function asUUID(id) {
  if (!id || !/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(id)) {
    throw new Error(`Invalid UUID format: ${id}`);
  }
  return id;
}
var ModelType = {
  SMALL: "TEXT_SMALL",
  // kept for backwards compatibility
  MEDIUM: "TEXT_LARGE",
  // kept for backwards compatibility
  LARGE: "TEXT_LARGE",
  // kept for backwards compatibility
  TEXT_SMALL: "TEXT_SMALL",
  TEXT_LARGE: "TEXT_LARGE",
  TEXT_EMBEDDING: "TEXT_EMBEDDING",
  TEXT_TOKENIZER_ENCODE: "TEXT_TOKENIZER_ENCODE",
  TEXT_TOKENIZER_DECODE: "TEXT_TOKENIZER_DECODE",
  TEXT_REASONING_SMALL: "REASONING_SMALL",
  TEXT_REASONING_LARGE: "REASONING_LARGE",
  TEXT_COMPLETION: "TEXT_COMPLETION",
  IMAGE: "IMAGE",
  IMAGE_DESCRIPTION: "IMAGE_DESCRIPTION",
  TRANSCRIPTION: "TRANSCRIPTION",
  TEXT_TO_SPEECH: "TEXT_TO_SPEECH",
  AUDIO: "AUDIO",
  VIDEO: "VIDEO",
  OBJECT_SMALL: "OBJECT_SMALL",
  OBJECT_LARGE: "OBJECT_LARGE"
};
var ServiceType = {
  TRANSCRIPTION: "transcription",
  VIDEO: "video",
  BROWSER: "browser",
  PDF: "pdf",
  REMOTE_FILES: "aws_s3",
  WEB_SEARCH: "web_search",
  EMAIL: "email",
  TEE: "tee",
  TASK: "task"
};
var MemoryType = /* @__PURE__ */ ((MemoryType2) => {
  MemoryType2["DOCUMENT"] = "document";
  MemoryType2["FRAGMENT"] = "fragment";
  MemoryType2["MESSAGE"] = "message";
  MemoryType2["DESCRIPTION"] = "description";
  MemoryType2["CUSTOM"] = "custom";
  return MemoryType2;
})(MemoryType || {});
var ChannelType = /* @__PURE__ */ ((ChannelType2) => {
  ChannelType2["SELF"] = "SELF";
  ChannelType2["DM"] = "dm";
  ChannelType2["GROUP"] = "group";
  ChannelType2["VOICE_DM"] = "VOICE_DM";
  ChannelType2["VOICE_GROUP"] = "VOICE_GROUP";
  ChannelType2["FEED"] = "FEED";
  ChannelType2["THREAD"] = "THREAD";
  ChannelType2["WORLD"] = "WORLD";
  ChannelType2["FORUM"] = "FORUM";
  ChannelType2["API"] = "API";
  return ChannelType2;
})(ChannelType || {});
var Service = class {
  /** Runtime instance */
  runtime;
  constructor(runtime) {
    if (runtime) {
      this.runtime = runtime;
    }
  }
  /** Service type */
  static serviceType;
  /** Service configuration */
  config;
  /** Start service connection */
  static async start(_runtime) {
    throw new Error("Not implemented");
  }
  /** Stop service connection */
  static async stop(_runtime) {
    throw new Error("Not implemented");
  }
};
var AgentStatus = /* @__PURE__ */ ((AgentStatus2) => {
  AgentStatus2["ACTIVE"] = "active";
  AgentStatus2["INACTIVE"] = "inactive";
  return AgentStatus2;
})(AgentStatus || {});
var KnowledgeScope = /* @__PURE__ */ ((KnowledgeScope2) => {
  KnowledgeScope2["SHARED"] = "shared";
  KnowledgeScope2["PRIVATE"] = "private";
  return KnowledgeScope2;
})(KnowledgeScope || {});
var CacheKeyPrefix = /* @__PURE__ */ ((CacheKeyPrefix2) => {
  CacheKeyPrefix2["KNOWLEDGE"] = "knowledge";
  return CacheKeyPrefix2;
})(CacheKeyPrefix || {});
var TEEMode = /* @__PURE__ */ ((TEEMode2) => {
  TEEMode2["OFF"] = "OFF";
  TEEMode2["LOCAL"] = "LOCAL";
  TEEMode2["DOCKER"] = "DOCKER";
  TEEMode2["PRODUCTION"] = "PRODUCTION";
  return TEEMode2;
})(TEEMode || {});
var TeeType = /* @__PURE__ */ ((TeeType2) => {
  TeeType2["TDX_DSTACK"] = "tdx_dstack";
  return TeeType2;
})(TeeType || {});
var Role = /* @__PURE__ */ ((Role2) => {
  Role2["OWNER"] = "OWNER";
  Role2["ADMIN"] = "ADMIN";
  Role2["NONE"] = "NONE";
  return Role2;
})(Role || {});
var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2["WORLD_JOINED"] = "WORLD_JOINED";
  EventType2["WORLD_CONNECTED"] = "WORLD_CONNECTED";
  EventType2["WORLD_LEFT"] = "WORLD_LEFT";
  EventType2["ENTITY_JOINED"] = "ENTITY_JOINED";
  EventType2["ENTITY_LEFT"] = "ENTITY_LEFT";
  EventType2["ENTITY_UPDATED"] = "ENTITY_UPDATED";
  EventType2["ROOM_JOINED"] = "ROOM_JOINED";
  EventType2["ROOM_LEFT"] = "ROOM_LEFT";
  EventType2["MESSAGE_RECEIVED"] = "MESSAGE_RECEIVED";
  EventType2["MESSAGE_SENT"] = "MESSAGE_SENT";
  EventType2["VOICE_MESSAGE_RECEIVED"] = "VOICE_MESSAGE_RECEIVED";
  EventType2["VOICE_MESSAGE_SENT"] = "VOICE_MESSAGE_SENT";
  EventType2["REACTION_RECEIVED"] = "REACTION_RECEIVED";
  EventType2["POST_GENERATED"] = "POST_GENERATED";
  EventType2["INTERACTION_RECEIVED"] = "INTERACTION_RECEIVED";
  EventType2["RUN_STARTED"] = "RUN_STARTED";
  EventType2["RUN_ENDED"] = "RUN_ENDED";
  EventType2["RUN_TIMEOUT"] = "RUN_TIMEOUT";
  EventType2["ACTION_STARTED"] = "ACTION_STARTED";
  EventType2["ACTION_COMPLETED"] = "ACTION_COMPLETED";
  EventType2["EVALUATOR_STARTED"] = "EVALUATOR_STARTED";
  EventType2["EVALUATOR_COMPLETED"] = "EVALUATOR_COMPLETED";
  return EventType2;
})(EventType || {});
var PlatformPrefix = /* @__PURE__ */ ((PlatformPrefix2) => {
  PlatformPrefix2["DISCORD"] = "DISCORD";
  PlatformPrefix2["TELEGRAM"] = "TELEGRAM";
  PlatformPrefix2["TWITTER"] = "TWITTER";
  return PlatformPrefix2;
})(PlatformPrefix || {});
var SOCKET_MESSAGE_TYPE = /* @__PURE__ */ ((SOCKET_MESSAGE_TYPE2) => {
  SOCKET_MESSAGE_TYPE2[SOCKET_MESSAGE_TYPE2["ROOM_JOINING"] = 1] = "ROOM_JOINING";
  SOCKET_MESSAGE_TYPE2[SOCKET_MESSAGE_TYPE2["SEND_MESSAGE"] = 2] = "SEND_MESSAGE";
  SOCKET_MESSAGE_TYPE2[SOCKET_MESSAGE_TYPE2["MESSAGE"] = 3] = "MESSAGE";
  SOCKET_MESSAGE_TYPE2[SOCKET_MESSAGE_TYPE2["ACK"] = 4] = "ACK";
  SOCKET_MESSAGE_TYPE2[SOCKET_MESSAGE_TYPE2["THINKING"] = 5] = "THINKING";
  return SOCKET_MESSAGE_TYPE2;
})(SOCKET_MESSAGE_TYPE || {});
function createMessageMemory(params) {
  return {
    ...params,
    createdAt: Date.now(),
    metadata: {
      type: "message" /* MESSAGE */,
      timestamp: Date.now(),
      scope: params.agentId ? "private" : "shared"
    }
  };
}
function getTypedService(runtime, serviceType) {
  return runtime.getService(serviceType);
}
function isDocumentMetadata(metadata) {
  return metadata.type === "document" /* DOCUMENT */;
}
function isFragmentMetadata(metadata) {
  return metadata.type === "fragment" /* FRAGMENT */;
}
function isMessageMetadata(metadata) {
  return metadata.type === "message" /* MESSAGE */;
}
function isDescriptionMetadata(metadata) {
  return metadata.type === "description" /* DESCRIPTION */;
}
function isCustomMetadata(metadata) {
  return metadata.type !== "document" /* DOCUMENT */ && metadata.type !== "fragment" /* FRAGMENT */ && metadata.type !== "message" /* MESSAGE */ && metadata.type !== "description" /* DESCRIPTION */;
}
function getVideoService(runtime) {
  return runtime.getService(ServiceType.VIDEO);
}
function getBrowserService(runtime) {
  return runtime.getService(ServiceType.BROWSER);
}
function getPdfService(runtime) {
  return runtime.getService(ServiceType.PDF);
}
function getFileService(runtime) {
  return runtime.getService(ServiceType.REMOTE_FILES);
}
function isDocumentMemory(memory) {
  return memory.metadata?.type === "document" /* DOCUMENT */;
}
function isFragmentMemory(memory) {
  return memory.metadata?.type === "fragment" /* FRAGMENT */;
}
function getMemoryText(memory, defaultValue = "") {
  return memory.content.text ?? defaultValue;
}
function createServiceError(error, code = "UNKNOWN_ERROR") {
  if (error instanceof Error) {
    return {
      code,
      message: error.message,
      cause: error
    };
  }
  return {
    code,
    message: String(error)
  };
}

// src/actions.ts
import { names, uniqueNamesGenerator } from "unique-names-generator";
var composeActionExamples = (actionsData, count) => {
  const data = actionsData.map((action) => [...action.examples]);
  const actionExamples = [];
  let length = data.length;
  for (let i = 0; i < count && length; i++) {
    const actionId = i % length;
    const examples = data[actionId];
    if (examples.length) {
      const rand = ~~(Math.random() * examples.length);
      actionExamples[i] = examples.splice(rand, 1)[0];
    } else {
      i--;
    }
    if (examples.length === 0) {
      data.splice(actionId, 1);
      length--;
    }
  }
  const formattedExamples = actionExamples.map((example) => {
    const exampleNames = Array.from(
      { length: 5 },
      () => uniqueNamesGenerator({ dictionaries: [names] })
    );
    return `
${example.map((message) => {
      let messageString = `${message.name}: ${message.content.text}${message.content.action ? ` (action: ${message.content.action})` : ""}${message.content.actions ? ` (actions: ${message.content.actions.join(", ")})` : ""}`;
      for (let i = 0; i < exampleNames.length; i++) {
        messageString = messageString.replaceAll(`{{name${i + 1}}}`, exampleNames[i]);
      }
      return messageString;
    }).join("\n")}`;
  });
  return formattedExamples.join("\n");
};
function formatActionNames(actions) {
  return actions.sort(() => 0.5 - Math.random()).map((action) => `${action.name}`).join(", ");
}
function formatActions(actions) {
  return actions.sort(() => 0.5 - Math.random()).map((action) => `${action.name}: ${action.description}`).join(",\n");
}

// src/database.ts
var DatabaseAdapter = class {
  /**
   * The database instance.
   */
  db;
};

// src/prompts.ts
import handlebars from "handlebars";
import { RecursiveCharacterTextSplitter } from "langchain/text_splitter";
import { names as names2, uniqueNamesGenerator as uniqueNamesGenerator2 } from "unique-names-generator";

// src/logger.ts
import pino from "pino";
function parseBooleanFromText(value) {
  if (!value) return false;
  const affirmative = ["YES", "Y", "TRUE", "T", "1", "ON", "ENABLE"];
  const negative = ["NO", "N", "FALSE", "F", "0", "OFF", "DISABLE"];
  const normalizedText = value.trim().toUpperCase();
  if (affirmative.includes(normalizedText)) {
    return true;
  }
  if (negative.includes(normalizedText)) {
    return false;
  }
  return false;
}
var InMemoryDestination = class {
  logs = [];
  maxLogs = 1e3;
  // Keep last 1000 logs
  stream;
  /**
   * Constructor for creating a new instance of the class.
   * @param {DestinationStream|null} stream - The stream to assign to the instance. Can be null.
   */
  constructor(stream) {
    this.stream = stream;
  }
  /**
   * Writes a log entry to the memory buffer and forwards it to the pretty print stream if available.
   *
   * @param {string | LogEntry} data - The data to be written, which can be either a string or a LogEntry object.
   * @returns {void}
   */
  write(data) {
    let logEntry;
    let stringData;
    if (typeof data === "string") {
      stringData = data;
      try {
        logEntry = JSON.parse(data);
      } catch (e) {
        if (this.stream) {
          this.stream.write(data);
        }
        return;
      }
    } else {
      logEntry = data;
      stringData = JSON.stringify(data);
    }
    if (!logEntry.time) {
      logEntry.time = Date.now();
    }
    const isDebugMode2 = (process?.env?.LOG_LEVEL || "").toLowerCase() === "debug";
    const isLoggingDiagnostic = Boolean(process?.env?.LOG_DIAGNOSTIC);
    if (isLoggingDiagnostic) {
      logEntry.diagnostic = true;
    }
    if (!isDebugMode2) {
      if (logEntry.agentName && logEntry.agentId) {
        const msg = logEntry.msg || "";
        if (typeof msg === "string" && (msg.includes("registered successfully") || msg.includes("Registering") || msg.includes("Success:") || msg.includes("linked to") || msg.includes("Started"))) {
          if (isLoggingDiagnostic) {
            console.error("Filtered log:", stringData);
          }
          return;
        }
      }
    }
    this.logs.push(logEntry);
    if (this.logs.length > this.maxLogs) {
      this.logs.shift();
    }
    if (this.stream) {
      this.stream.write(stringData);
    }
  }
  /**
   * Retrieves the recent logs from the system.
   *
   * @returns {LogEntry[]} An array of LogEntry objects representing the recent logs.
   */
  recentLogs() {
    return this.logs;
  }
  /**
   * Clears all logs from memory.
   *
   * @returns {void}
   */
  clear() {
    this.logs = [];
  }
};
var customLevels = {
  fatal: 60,
  error: 50,
  warn: 40,
  info: 30,
  log: 29,
  progress: 28,
  success: 27,
  debug: 20,
  trace: 10
};
var raw = parseBooleanFromText(process?.env?.LOG_JSON_FORMAT) || false;
var isDebugMode = (process?.env?.LOG_LEVEL || "").toLowerCase() === "debug";
var effectiveLogLevel = isDebugMode ? "debug" : process?.env?.DEFAULT_LOG_LEVEL || "info";
var createPrettyConfig = () => ({
  colorize: true,
  translateTime: "yyyy-mm-dd HH:MM:ss",
  ignore: "pid,hostname",
  customPrettifiers: {
    level: (inputData) => {
      let level;
      if (typeof inputData === "object" && inputData !== null) {
        level = inputData.level || inputData.value;
      } else {
        level = inputData;
      }
      const levelNames = {
        10: "TRACE",
        20: "DEBUG",
        27: "SUCCESS",
        28: "PROGRESS",
        29: "LOG",
        30: "INFO",
        40: "WARN",
        50: "ERROR",
        60: "FATAL"
      };
      if (typeof level === "number") {
        return levelNames[level] || `LEVEL${level}`;
      }
      if (level === void 0 || level === null) {
        return "UNKNOWN";
      }
      return String(level).toUpperCase();
    },
    // Add a custom prettifier for error messages
    msg: (msg) => {
      return msg.replace(/ERROR \([^)]+\):/g, "ERROR:");
    }
  },
  messageFormat: "{msg}"
});
var createStream = async () => {
  if (raw) {
    return void 0;
  }
  const pretty = await import("pino-pretty");
  return pretty.default(createPrettyConfig());
};
var options = {
  level: effectiveLogLevel,
  // Use more restrictive level unless in debug mode
  customLevels,
  hooks: {
    logMethod(inputArgs, method) {
      const [arg1, ...rest] = inputArgs;
      const formatError = (err) => ({
        message: `(${err.name}) ${err.message}`,
        stack: err.stack?.split("\n").map((line) => line.trim())
      });
      if (typeof arg1 === "object") {
        if (arg1 instanceof Error) {
          method.apply(this, [
            {
              error: formatError(arg1)
            }
          ]);
        } else {
          const messageParts = rest.map(
            (arg) => typeof arg === "string" ? arg : JSON.stringify(arg)
          );
          const message = messageParts.join(" ");
          method.apply(this, [arg1, message]);
        }
      } else {
        const context = {};
        const messageParts = [arg1, ...rest].map((arg) => {
          if (arg instanceof Error) {
            return formatError(arg);
          }
          return typeof arg === "string" ? arg : arg;
        });
        const message = messageParts.filter((part) => typeof part === "string").join(" ");
        const jsonParts = messageParts.filter((part) => typeof part === "object");
        Object.assign(context, ...jsonParts);
        method.apply(this, [context, message]);
      }
    }
  }
};
var logger = pino(options);
if (typeof process !== "undefined") {
  let stream = null;
  if (!raw) {
    try {
      const pretty = __require("pino-pretty");
      stream = pretty.default ? pretty.default(createPrettyConfig()) : null;
    } catch (e) {
      createStream().then((prettyStream) => {
        const destination = new InMemoryDestination(prettyStream);
        logger = pino(options, destination);
        logger[Symbol.for("pino-destination")] = destination;
        logger.clear = () => {
          const destination2 = logger[Symbol.for("pino-destination")];
          if (destination2 instanceof InMemoryDestination) {
            destination2.clear();
          }
        };
      });
    }
  }
  if (stream !== null || raw) {
    const destination = new InMemoryDestination(stream);
    logger = pino(options, destination);
    logger[Symbol.for("pino-destination")] = destination;
    logger.clear = () => {
      const destination2 = logger[Symbol.for("pino-destination")];
      if (destination2 instanceof InMemoryDestination) {
        destination2.clear();
      }
    };
  }
}
var elizaLogger = logger;
var logger_default = logger;

// src/prompts.ts
var composePrompt = ({
  state,
  template
}) => {
  const templateStr = typeof template === "function" ? template({ state }) : template;
  const templateFunction = handlebars.compile(templateStr);
  const output = composeRandomUser(templateFunction(state), 10);
  return output;
};
var composePromptFromState = ({
  state,
  template
}) => {
  const templateStr = typeof template === "function" ? template({ state }) : template;
  const templateFunction = handlebars.compile(templateStr);
  const stateKeys = Object.keys(state);
  const filteredKeys = stateKeys.filter((key) => !["text", "values", "data"].includes(key));
  const filteredState = filteredKeys.reduce((acc, key) => {
    acc[key] = state[key];
    return acc;
  }, {});
  const output = composeRandomUser(templateFunction({ ...filteredState, ...state.values }), 10);
  return output;
};
var addHeader = (header, body) => {
  return body.length > 0 ? `${header ? `${header}
` : header}${body}
` : "";
};
var composeRandomUser = (template, length) => {
  const exampleNames = Array.from(
    { length },
    () => uniqueNamesGenerator2({ dictionaries: [names2] })
  );
  let result = template;
  for (let i = 0; i < exampleNames.length; i++) {
    result = result.replaceAll(`{{name${i + 1}}}`, exampleNames[i]);
  }
  return result;
};
var formatPosts = ({
  messages,
  entities,
  conversationHeader = true
}) => {
  const groupedMessages = {};
  messages.forEach((message) => {
    if (message.roomId) {
      if (!groupedMessages[message.roomId]) {
        groupedMessages[message.roomId] = [];
      }
      groupedMessages[message.roomId].push(message);
    }
  });
  Object.values(groupedMessages).forEach((roomMessages) => {
    roomMessages.sort((a, b) => a.createdAt - b.createdAt);
  });
  const sortedRooms = Object.entries(groupedMessages).sort(
    ([, messagesA], [, messagesB]) => messagesB[messagesB.length - 1].createdAt - messagesA[messagesA.length - 1].createdAt
  );
  const formattedPosts = sortedRooms.map(([roomId, roomMessages]) => {
    const messageStrings = roomMessages.filter((message) => message.entityId).map((message) => {
      const entity = entities.find((entity2) => entity2.id === message.entityId);
      const userName = entity?.names[0] || "Unknown User";
      const displayName = entity?.names[0] || "unknown";
      return `Name: ${userName} (@${displayName})
ID: ${message.id}${message.content.inReplyTo ? `
In reply to: ${message.content.inReplyTo}` : ""}
Date: ${formatTimestamp(message.createdAt)}
Text:
${message.content.text}`;
    });
    const header = conversationHeader ? `Conversation: ${roomId.slice(-5)}
` : "";
    return `${header}${messageStrings.join("\n\n")}`;
  });
  return formattedPosts.join("\n\n");
};
var formatMessages = ({
  messages,
  entities
}) => {
  const messageStrings = messages.reverse().filter((message) => message.entityId).map((message) => {
    const messageText = message.content.text;
    const messageActions = message.content.actions;
    const messageThought = message.content.thought;
    const formattedName = entities.find((entity) => entity.id === message.entityId)?.names[0] || "Unknown User";
    const attachments = message.content.attachments;
    const attachmentString = attachments && attachments.length > 0 ? ` (Attachments: ${attachments.map((media) => `[${media.id} - ${media.title} (${media.url})]`).join(", ")})` : null;
    const messageTime = new Date(message.createdAt);
    const hours = messageTime.getHours().toString().padStart(2, "0");
    const minutes = messageTime.getMinutes().toString().padStart(2, "0");
    const timeString = `${hours}:${minutes}`;
    const timestamp = formatTimestamp(message.createdAt);
    const shortId = message.entityId.slice(-5);
    const thoughtString = messageThought ? `(${formattedName}'s internal thought: ${messageThought})` : null;
    const timestampString = `${timeString} (${timestamp}) [${shortId}]`;
    const textString = messageText ? `${timestampString} ${formattedName}: ${messageText}` : null;
    const actionString = messageActions && messageActions.length > 0 ? `${textString ? "" : timestampString} (${formattedName}'s actions: ${messageActions.join(", ")})` : null;
    const messageString = [textString, thoughtString, actionString, attachmentString].filter(Boolean).join("\n");
    return messageString;
  }).join("\n");
  return messageStrings;
};
var formatTimestamp = (messageDate) => {
  const now = /* @__PURE__ */ new Date();
  const diff = now.getTime() - messageDate;
  const absDiff = Math.abs(diff);
  const seconds = Math.floor(absDiff / 1e3);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);
  if (absDiff < 6e4) {
    return "just now";
  }
  if (minutes < 60) {
    return `${minutes} minute${minutes !== 1 ? "s" : ""} ago`;
  }
  if (hours < 24) {
    return `${hours} hour${hours !== 1 ? "s" : ""} ago`;
  }
  return `${days} day${days !== 1 ? "s" : ""} ago`;
};
var jsonBlockPattern = /```json\n([\s\S]*?)\n```/;
var shouldRespondTemplate = `# Task: Decide on behalf of {{agentName}} whether they should respond to the message, ignore it or stop the conversation.
{{providers}}
# Instructions: Decide if {{agentName}} should respond to or interact with the conversation.
If the message is directed at or relevant to {{agentName}}, respond with RESPOND action.
If a user asks {{agentName}} to be quiet, respond with STOP action.
If {{agentName}} should ignore the message, respond with IGNORE action.
If responding with the RESPOND action, include a list of optional providers that could be relevant to the response.
Response format should be formatted in a valid JSON block like this:
\`\`\`json
{
    "name": "{{agentName}}",
	"reasoning": "<string>",
    "action": "RESPOND" | "IGNORE" | "STOP",
    "providers": ["<string>", "<string>", ...]
}
\`\`\`
Your response should include the valid JSON block and nothing else.`;
var messageHandlerTemplate = `# Task: Generate dialog and actions for the character {{agentName}}.
{{providers}}
# Instructions: Write a thought and plan for {{agentName}} and decide what actions to take. Also include the providers that {{agentName}} will use to have the right context for responding and acting, if any.
First, think about what you want to do next and plan your actions. Then, write the next message and include the actions you plan to take.
"thought" should be a short description of what the agent is thinking about and planning.
"actions" should be an array of the actions {{agentName}} plans to take based on the thought (if none, use IGNORE, if simply responding with text, use REPLY)
"providers" should be an optional array of the providers that {{agentName}} will use to have the right context for responding and acting
"evaluators" should be an optional array of the evaluators that {{agentName}} will use to evaluate the conversation after responding
These are the available valid actions: {{actionNames}}

Response format should be formatted in a valid JSON block like this:
\`\`\`json
{
    "thought": "<string>",
    "actions": ["<string>", "<string>", ...],
    "providers": ["<string>", "<string>", ...]
}
\`\`\`

Your response should include the valid JSON block and nothing else.`;
var postCreationTemplate = `# Task: Create a post in the voice and style and perspective of {{agentName}} @{{twitterUserName}}.

Example task outputs:
1. A post about the importance of AI in our lives
\`\`\`json
{ "thought": "I am thinking about writing a post about the importance of AI in our lives", "post": "AI is changing the world and it is important to understand how it works", "imagePrompt": "A futuristic cityscape with flying cars and people using AI to do things" }
\`\`\`

2. A post about dogs
\`\`\`json
{ "thought": "I am thinking about writing a post about dogs", "post": "Dogs are man's best friend and they are loyal and loving", "imagePrompt": "A dog playing with a ball in a park" }
\`\`\`

3. A post about finding a new job
\`\`\`json
{ "thought": "Getting a job is hard, I bet there's a good tweet in that", "post": "Just keep going!", "imagePrompt": "A person looking at a computer screen with a job search website" }
\`\`\`

{{providers}}

Write a post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.
Your response should be 1, 2, or 3 sentences (choose the length at random).
Your response should not contain any questions. Brief, concise statements only. The total character count MUST be less than 280. No emojis. Use \\n\\n (double spaces) between statements if there are multiple statements in your response.

Your output should be formatted in a valid JSON block like this:
\`\`\`json
{ "thought": "<string>", "post": "<string>", "imagePrompt": "<string>" }
\`\`\`
The "post" field should be the post you want to send. Do not including any thinking or internal reflection in the "post" field.
The "imagePrompt" field is optional and should be a prompt for an image that is relevant to the post. It should be a single sentence that captures the essence of the post. ONLY USE THIS FIELD if it makes sense that the post would benefit from an image.
The "thought" field should be a short description of what the agent is thinking about before responding, inlcuding a brief justification for the response. Includate an explanation how the post is relevant to the topic but unique and different than other posts.
Your reponse should ONLY contain a valid JSON block and nothing else.`;
var booleanFooter = "Respond with only a YES or a NO.";
function parseBooleanFromText2(value) {
  if (!value) return false;
  const affirmative = ["YES", "Y", "TRUE", "T", "1", "ON", "ENABLE"];
  const negative = ["NO", "N", "FALSE", "F", "0", "OFF", "DISABLE"];
  const normalizedText = value.trim().toUpperCase();
  if (affirmative.includes(normalizedText)) {
    return true;
  }
  if (negative.includes(normalizedText)) {
    return false;
  }
  return false;
}
var stringArrayFooter = `Respond with a JSON array containing the values in a valid JSON block formatted for markdown with this structure:
\`\`\`json
[
  'value',
  'value'
]
\`\`\`

Your response must include the valid JSON block.`;
function parseJsonArrayFromText(text) {
  let jsonData = null;
  const jsonBlockMatch = text?.match(jsonBlockPattern);
  if (jsonBlockMatch) {
    try {
      const normalizedJson = jsonBlockMatch[1].replace(/(?<!\\)'([^']*)'(?=\s*[,}\]])/g, '"$1"');
      jsonData = JSON.parse(normalizeJsonString(normalizedJson));
    } catch (_e) {
      logger_default.warn("Could not parse text as JSON, will try pattern matching");
    }
  }
  if (!jsonData) {
    const arrayPattern = /\[\s*(['"])(.*?)\1\s*\]/;
    const arrayMatch = text.match(arrayPattern);
    if (arrayMatch) {
      try {
        const normalizedJson = arrayMatch[0].replace(/(?<!\\)'([^']*)'(?=\s*[,}\]])/g, '"$1"');
        jsonData = JSON.parse(normalizeJsonString(normalizedJson));
      } catch (_e) {
        logger_default.warn("Could not parse text as JSON, returning null");
      }
    }
  }
  if (Array.isArray(jsonData)) {
    return jsonData;
  }
  return null;
}
function parseJSONObjectFromText(text) {
  let jsonData = null;
  const jsonBlockMatch = text.match(jsonBlockPattern);
  try {
    if (jsonBlockMatch) {
      jsonData = JSON.parse(normalizeJsonString(jsonBlockMatch[1].trim()));
    } else {
      jsonData = JSON.parse(normalizeJsonString(text.trim()));
    }
  } catch (_e) {
    logger_default.warn("Could not parse text as JSON, returning null");
    return null;
  }
  if (jsonData && typeof jsonData === "object" && !Array.isArray(jsonData)) {
    return jsonData;
  }
  logger_default.warn("Could not parse text as JSON, returning null");
  return null;
}
function extractAttributes(response, attributesToExtract) {
  const attributes = {};
  if (!attributesToExtract || attributesToExtract.length === 0) {
    const matches = response.matchAll(/"([^"]+)"\s*:\s*"([^"]*)"/g);
    for (const match of matches) {
      attributes[match[1]] = match[2];
    }
  } else {
    for (const attribute of attributesToExtract) {
      const match = response.match(new RegExp(`"${attribute}"\\s*:\\s*"([^"]*)"`, "i"));
      if (match) {
        attributes[attribute] = match[1];
      }
    }
  }
  return attributes;
}
var normalizeJsonString = (str) => {
  str = str.replace(/\{\s+/, "{").replace(/\s+\}/, "}").trim();
  str = str.replace(/("[\w\d_-]+")\s*: \s*(?!"|\[)([\s\S]+?)(?=(,\s*"|\}$))/g, '$1: "$2"');
  str = str.replace(/"([^"]+)"\s*:\s*'([^']*)'/g, (_, key, value) => `"${key}": "${value}"`);
  str = str.replace(/("[\w\d_-]+")\s*:\s*([A-Za-z_]+)(?!["\w])/g, '$1: "$2"');
  str = str.replace(/(?:"')|(?:'")/g, '"');
  return str;
};
function cleanJsonResponse(response) {
  return response.replace(/```json\s*/g, "").replace(/```\s*/g, "").replace(/(\r\n|\n|\r)/g, "").trim();
}
var postActionResponseFooter = "Choose any combination of [LIKE], [RETWEET], [QUOTE], and [REPLY] that are appropriate. Each action must be on its own line. Your response must only include the chosen actions.";
var parseActionResponseFromText = (text) => {
  const actions = {
    like: false,
    retweet: false,
    quote: false,
    reply: false
  };
  const likePattern = /\[LIKE\]/i;
  const retweetPattern = /\[RETWEET\]/i;
  const quotePattern = /\[QUOTE\]/i;
  const replyPattern = /\[REPLY\]/i;
  actions.like = likePattern.test(text);
  actions.retweet = retweetPattern.test(text);
  actions.quote = quotePattern.test(text);
  actions.reply = replyPattern.test(text);
  const lines = text.split("\n");
  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed === "[LIKE]") actions.like = true;
    if (trimmed === "[RETWEET]") actions.retweet = true;
    if (trimmed === "[QUOTE]") actions.quote = true;
    if (trimmed === "[REPLY]") actions.reply = true;
  }
  return { actions };
};
function truncateToCompleteSentence(text, maxLength) {
  if (text.length <= maxLength) {
    return text;
  }
  const lastPeriodIndex = text.lastIndexOf(".", maxLength - 1);
  if (lastPeriodIndex !== -1) {
    const truncatedAtPeriod = text.slice(0, lastPeriodIndex + 1).trim();
    if (truncatedAtPeriod.length > 0) {
      return truncatedAtPeriod;
    }
  }
  const lastSpaceIndex = text.lastIndexOf(" ", maxLength - 1);
  if (lastSpaceIndex !== -1) {
    const truncatedAtSpace = text.slice(0, lastSpaceIndex).trim();
    if (truncatedAtSpace.length > 0) {
      return `${truncatedAtSpace}...`;
    }
  }
  const hardTruncated = text.slice(0, maxLength - 3).trim();
  return `${hardTruncated}...`;
}
var TOKENS_PER_CHAR = 4;
var TARGET_TOKENS = 3e3;
var _TARGET_CHARS = Math.floor(TARGET_TOKENS / TOKENS_PER_CHAR);
async function splitChunks(content, chunkSize = 512, bleed = 20) {
  logger_default.debug("[splitChunks] Starting text split");
  const textSplitter = new RecursiveCharacterTextSplitter({
    chunkSize: Number(chunkSize),
    chunkOverlap: Number(bleed)
  });
  const chunks = await textSplitter.splitText(content);
  logger_default.debug("[splitChunks] Split complete:", {
    numberOfChunks: chunks.length,
    averageChunkSize: chunks.reduce((acc, chunk) => acc + chunk.length, 0) / chunks.length
  });
  return chunks;
}
async function trimTokens(prompt, maxTokens, runtime) {
  if (!prompt) throw new Error("Trim tokens received a null prompt");
  if (prompt.length < maxTokens / 5) return prompt;
  if (maxTokens <= 0) throw new Error("maxTokens must be positive");
  try {
    const tokens = await runtime.useModel(ModelType.TEXT_TOKENIZER_ENCODE, {
      prompt
    });
    if (tokens.length <= maxTokens) {
      return prompt;
    }
    const truncatedTokens = tokens.slice(-maxTokens);
    return await runtime.useModel(ModelType.TEXT_TOKENIZER_DECODE, {
      tokens: truncatedTokens
    });
  } catch (error) {
    logger_default.error("Error in trimTokens:", error);
    return prompt.slice(-maxTokens * 4);
  }
}

// src/entities.ts
var entityResolutionTemplate = `# Task: Resolve Entity Name
Message Sender: {{senderName}} (ID: {{senderId}})
Agent: {{agentName}} (ID: {{agentId}})

# Entities in Room:
{{#if entitiesInRoom}}
{{entitiesInRoom}}
{{/if}}

{{recentMessages}}

# Instructions:
1. Analyze the context to identify which entity is being referenced
2. Consider special references like "me" (the message sender) or "you" (agent the message is directed to)
3. Look for usernames/handles in standard formats (e.g. @username, user#1234)
4. Consider context from recent messages for pronouns and references
5. If multiple matches exist, use context to disambiguate
6. Consider recent interactions and relationship strength when resolving ambiguity

Return a JSON object with:
\`\`\`json
{
  "entityId": "exact-id-if-known-otherwise-null",
  "type": "EXACT_MATCH | USERNAME_MATCH | NAME_MATCH | RELATIONSHIP_MATCH | AMBIGUOUS | UNKNOWN",
  "matches": [{
    "name": "matched-name",
    "reason": "why this entity matches"
  }]
}
\`\`\`

Make sure to include the \`\`\`json\`\`\` tags around the JSON object.
`;
async function getRecentInteractions(runtime, sourceEntityId, candidateEntities, roomId, relationships) {
  const results = [];
  const recentMessages = await runtime.getMemories({
    tableName: "messages",
    roomId,
    count: 20
    // Reduced from 100 since we only need context
  });
  for (const entity of candidateEntities) {
    const interactions = [];
    let interactionScore = 0;
    const directReplies = recentMessages.filter(
      (msg) => msg.entityId === sourceEntityId && msg.content.inReplyTo === entity.id || msg.entityId === entity.id && msg.content.inReplyTo === sourceEntityId
    );
    interactions.push(...directReplies);
    const relationship = relationships.find(
      (rel) => rel.sourceEntityId === sourceEntityId && rel.targetEntityId === entity.id || rel.targetEntityId === sourceEntityId && rel.sourceEntityId === entity.id
    );
    if (relationship?.metadata?.interactions) {
      interactionScore = relationship.metadata.interactions;
    }
    interactionScore += directReplies.length;
    const uniqueInteractions = [...new Set(interactions)];
    results.push({
      entity,
      interactions: uniqueInteractions.slice(-5),
      // Only keep last 5 messages for context
      count: Math.round(interactionScore)
    });
  }
  return results.sort((a, b) => b.count - a.count);
}
async function findEntityByName(runtime, message, state) {
  try {
    const room = state.data.room ?? await runtime.getRoom(message.roomId);
    if (!room) {
      logger.warn("Room not found for entity search");
      return null;
    }
    const world = room.worldId ? await runtime.getWorld(room.worldId) : null;
    const entitiesInRoom = await runtime.getEntitiesForRoom(room.id, true);
    const filteredEntities = await Promise.all(
      entitiesInRoom.map(async (entity) => {
        if (!entity.components) return entity;
        const worldRoles = world?.metadata?.roles || {};
        entity.components = entity.components.filter((component) => {
          if (component.sourceEntityId === message.entityId) return true;
          if (world && component.sourceEntityId) {
            const sourceRole = worldRoles[component.sourceEntityId];
            if (sourceRole === "OWNER" || sourceRole === "ADMIN") return true;
          }
          if (component.sourceEntityId === runtime.agentId) return true;
          return false;
        });
        return entity;
      })
    );
    const relationships = await runtime.getRelationships({
      entityId: message.entityId
    });
    const relationshipEntities = await Promise.all(
      relationships.map(async (rel) => {
        const entityId = rel.sourceEntityId === message.entityId ? rel.targetEntityId : rel.sourceEntityId;
        return runtime.getEntityById(entityId);
      })
    );
    const allEntities = [
      ...filteredEntities,
      ...relationshipEntities.filter((e) => e !== null)
    ];
    const interactionData = await getRecentInteractions(
      runtime,
      message.entityId,
      allEntities,
      room.id,
      relationships
    );
    const prompt = composePrompt({
      state: {
        roomName: room.name || room.id,
        worldName: world?.name || "Unknown",
        entitiesInRoom: JSON.stringify(filteredEntities, null, 2),
        entityId: message.entityId,
        senderId: message.entityId
      },
      template: entityResolutionTemplate
    });
    const result = await runtime.useModel(ModelType.TEXT_SMALL, {
      prompt,
      stopSequences: []
    });
    const resolution = parseJSONObjectFromText(result);
    if (!resolution) {
      logger.warn("Failed to parse entity resolution result");
      return null;
    }
    if (resolution.type === "EXACT_MATCH" && resolution.entityId) {
      const entity = await runtime.getEntityById(resolution.entityId);
      if (entity) {
        if (entity.components) {
          const worldRoles = world?.metadata?.roles || {};
          entity.components = entity.components.filter((component) => {
            if (component.sourceEntityId === message.entityId) return true;
            if (world && component.sourceEntityId) {
              const sourceRole = worldRoles[component.sourceEntityId];
              if (sourceRole === "OWNER" || sourceRole === "ADMIN") return true;
            }
            if (component.sourceEntityId === runtime.agentId) return true;
            return false;
          });
        }
        return entity;
      }
    }
    if (resolution.matches?.[0]?.name) {
      const matchName = resolution.matches[0].name.toLowerCase();
      const matchingEntity = allEntities.find((entity) => {
        if (entity.names.some((n) => n.toLowerCase() === matchName)) return true;
        return entity.components?.some(
          (c) => c.data.username?.toLowerCase() === matchName || c.data.handle?.toLowerCase() === matchName
        );
      });
      if (matchingEntity) {
        if (resolution.type === "RELATIONSHIP_MATCH") {
          const interactionInfo = interactionData.find((d) => d.entity.id === matchingEntity.id);
          if (interactionInfo && interactionInfo.count > 0) {
            return matchingEntity;
          }
        } else {
          return matchingEntity;
        }
      }
    }
    return null;
  } catch (error) {
    logger.error("Error in findEntityByName:", error);
    return null;
  }
}
var createUniqueUuid = (runtime, baseUserId) => {
  if (baseUserId === runtime.agentId) {
    return runtime.agentId;
  }
  const combinedString = `${baseUserId}:${runtime.agentId}`;
  return stringToUuid(combinedString);
};
async function getEntityDetails({
  runtime,
  roomId
}) {
  const [room, roomEntities] = await Promise.all([
    runtime.getRoom(roomId),
    runtime.getEntitiesForRoom(roomId, true)
  ]);
  const uniqueEntities = /* @__PURE__ */ new Map();
  for (const entity of roomEntities) {
    if (uniqueEntities.has(entity.id)) continue;
    const allData = {};
    for (const component of entity.components || []) {
      Object.assign(allData, component.data);
    }
    const mergedData = {};
    for (const [key, value] of Object.entries(allData)) {
      if (!mergedData[key]) {
        mergedData[key] = value;
        continue;
      }
      if (Array.isArray(mergedData[key]) && Array.isArray(value)) {
        mergedData[key] = [.../* @__PURE__ */ new Set([...mergedData[key], ...value])];
      } else if (typeof mergedData[key] === "object" && typeof value === "object") {
        mergedData[key] = { ...mergedData[key], ...value };
      }
    }
    uniqueEntities.set(entity.id, {
      id: entity.id,
      name: entity.metadata[room.source]?.name || entity.names[0],
      names: entity.names,
      data: JSON.stringify({ ...mergedData, ...entity.metadata })
    });
  }
  return Array.from(uniqueEntities.values());
}
function formatEntities({ entities }) {
  const entityStrings = entities.map((entity) => {
    const header = `${entity.names.join(" aka ")}
ID: ${entity.id}${entity.metadata && Object.keys(entity.metadata).length > 0 ? `
Data: ${JSON.stringify(entity.metadata)}
` : "\n"}`;
    return header;
  });
  return entityStrings.join("\n");
}

// src/import.ts
var registrations = /* @__PURE__ */ new Map();
var dynamicImport = async (specifier) => {
  const module = registrations.get(specifier);
  if (module !== void 0) {
    return module;
  }
  return await import(specifier);
};
var registerDynamicImport = (specifier, module) => {
  registrations.set(specifier, module);
};
async function handlePluginImporting(plugins) {
  if (plugins.length > 0) {
    const importedPlugins = await Promise.all(
      plugins.map(async (plugin) => {
        try {
          const importedPlugin = await import(plugin);
          const functionName = `${plugin.replace("@elizaos/plugin-", "").replace("@elizaos-plugins/", "").replace(/-./g, (x) => x[1].toUpperCase())}Plugin`;
          return importedPlugin.default || importedPlugin[functionName];
        } catch (importError) {
          logger_default.error(`Failed to import plugin: ${plugin}`, importError);
          return [];
        }
      })
    );
    return importedPlugins;
  }
  return [];
}

// src/roles.ts
async function getUserServerRole(runtime, entityId, serverId) {
  try {
    const worldId = createUniqueUuid(runtime, serverId);
    const world = await runtime.getWorld(worldId);
    if (!world || !world.metadata?.roles) {
      return "NONE" /* NONE */;
    }
    if (world.metadata.roles[entityId]) {
      return world.metadata.roles[entityId];
    }
    if (world.metadata.roles[entityId]) {
      return world.metadata.roles[entityId];
    }
    return "NONE" /* NONE */;
  } catch (error) {
    logger.error(`Error getting user role: ${error}`);
    return "NONE" /* NONE */;
  }
}
async function findWorldForOwner(runtime, entityId) {
  try {
    if (!entityId) {
      logger.error("User ID is required to find server");
      return null;
    }
    const worlds = await runtime.getAllWorlds();
    if (!worlds || worlds.length === 0) {
      logger.info("No worlds found for this agent");
      return null;
    }
    for (const world of worlds) {
      if (world.metadata?.ownership?.ownerId === entityId) {
        return world;
      }
    }
    logger.debug(`No server found for owner ${entityId}`);
    return null;
  } catch (error) {
    logger.error(`Error finding server for owner: ${error}`);
    return null;
  }
}

// src/runtime.ts
import { v4 as uuidv43 } from "uuid";

// src/bootstrap.ts
import fs from "node:fs";
import path from "node:path";
import { v4 } from "uuid";

// src/actions/choice.ts
var optionExtractionTemplate = `# Task: Extract selected task and option from user message

# Available Tasks:
{{#each tasks}}
Task ID: {{taskId}} - {{name}}
Available options:
{{#each options}}
- {{name}}: {{description}}
{{/each}}
- ABORT: Cancel this task

{{/each}}

# Recent Messages:
{{recentMessages}}

# Instructions:
1. Review the user's message and identify which task and option they are selecting
2. Match against the available tasks and their options, including ABORT
3. Return the task ID (shortened UUID) and selected option name exactly as listed above
4. If no clear selection is made, return null for both fields

Return in JSON format:
\`\`\`json
{
  "taskId": "string" | null,
  "selectedOption": "OPTION_NAME" | null
}
\`\`\`

Make sure to include the \`\`\`json\`\`\` tags around the JSON object.`;
var choiceAction = {
  name: "CHOOSE_OPTION",
  similes: ["SELECT_OPTION", "SELECT", "PICK", "CHOOSE"],
  description: "Selects an option for a pending task that has multiple options",
  validate: async (runtime, message, state) => {
    const pendingTasks = await runtime.getTasks({
      roomId: message.roomId,
      tags: ["AWAITING_CHOICE"]
    });
    const room = state.data.room ?? await runtime.getRoom(message.roomId);
    const userRole = await getUserServerRole(runtime, message.entityId, room.serverId);
    if (userRole !== "OWNER" && userRole !== "ADMIN") {
      return false;
    }
    return pendingTasks && pendingTasks.length > 0 && pendingTasks.some((task) => task.metadata?.options);
  },
  handler: async (runtime, message, state, _options, callback, responses) => {
    try {
      const pendingTasks = await runtime.getTasks({
        roomId: message.roomId,
        tags: ["AWAITING_CHOICE"]
      });
      if (!pendingTasks?.length) {
        throw new Error("No pending tasks with options found");
      }
      const tasksWithOptions = pendingTasks.filter((task) => task.metadata?.options);
      if (!tasksWithOptions.length) {
        throw new Error("No tasks currently have options to select from.");
      }
      const formattedTasks = tasksWithOptions.map((task) => {
        const shortId = task.id.substring(0, 8);
        return {
          taskId: shortId,
          fullId: task.id,
          name: task.name,
          options: task.metadata.options.map((opt) => ({
            name: typeof opt === "string" ? opt : opt.name,
            description: typeof opt === "string" ? opt : opt.description || opt.name
          }))
        };
      });
      const tasksString = formattedTasks.map((task) => {
        return `Task ID: ${task.taskId} - ${task.name}
Available options:
${task.options.map((opt) => `- ${opt.name}: ${opt.description}`).join("\n")}`;
      }).join("\n");
      const prompt = composePrompt({
        state: {
          tasks: tasksString,
          recentMessages: message.content.text
        },
        template: optionExtractionTemplate
      });
      const result = await runtime.useModel(ModelType.TEXT_SMALL, {
        prompt,
        stopSequences: []
      });
      const parsed = parseJSONObjectFromText(result);
      const { taskId, selectedOption } = parsed;
      if (taskId && selectedOption) {
        const taskMap = new Map(formattedTasks.map((task) => [task.taskId, task]));
        const taskInfo = taskMap.get(taskId);
        if (!taskInfo) {
          await callback({
            text: `Could not find a task matching ID: ${taskId}. Please try again.`,
            actions: ["SELECT_OPTION_ERROR"],
            source: message.content.source
          });
          return;
        }
        const selectedTask = tasksWithOptions.find((task) => task.id === taskInfo.fullId);
        if (!selectedTask) {
          await callback({
            text: "Error locating the selected task. Please try again.",
            actions: ["SELECT_OPTION_ERROR"],
            source: message.content.source
          });
          return;
        }
        if (selectedOption === "ABORT") {
          await runtime.deleteTask(selectedTask.id);
          await callback({
            text: `Task "${selectedTask.name}" has been cancelled.`,
            actions: ["CHOOSE_OPTION_CANCELLED"],
            source: message.content.source
          });
          return;
        }
        try {
          const taskWorker = runtime.getTaskWorker(selectedTask.name);
          await taskWorker.execute(runtime, { option: selectedOption }, selectedTask);
          await callback({
            text: `Selected option: ${selectedOption} for task: ${selectedTask.name}`,
            actions: ["CHOOSE_OPTION"],
            source: message.content.source
          });
          return;
        } catch (error) {
          logger.error("Error executing task with option:", error);
          await callback({
            text: "There was an error processing your selection.",
            actions: ["SELECT_OPTION_ERROR"],
            source: message.content.source
          });
          return;
        }
      }
      let optionsText = "Please select a valid option from one of these tasks:\n\n";
      tasksWithOptions.forEach((task) => {
        const shortId = task.id.substring(0, 8);
        optionsText += `**${task.name}** (ID: ${shortId}):
`;
        const options2 = task.metadata.options.map(
          (opt) => typeof opt === "string" ? opt : opt.name
        );
        options2.push("ABORT");
        optionsText += options2.map((opt) => `- ${opt}`).join("\n");
        optionsText += "\n\n";
      });
      await callback({
        text: optionsText,
        actions: ["SELECT_OPTION_INVALID"],
        source: message.content.source
      });
    } catch (error) {
      logger.error("Error in select option handler:", error);
      await callback({
        text: "There was an error processing the option selection.",
        actions: ["SELECT_OPTION_ERROR"],
        source: message.content.source
      });
    }
  },
  examples: [
    [
      {
        name: "{{name1}}",
        content: {
          text: "post"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Selected option: post for task: Confirm Twitter Post",
          actions: ["CHOOSE_OPTION"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "I choose cancel"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Selected option: cancel for task: Confirm Twitter Post",
          actions: ["CHOOSE_OPTION"]
        }
      }
    ]
  ]
};

// src/actions/followRoom.ts
var shouldFollowTemplate = `# Task: Decide if {{agentName}} should start following this room, i.e. eagerly participating without explicit mentions.

{{recentMessages}}

Should {{agentName}} start following this room, eagerly participating without explicit mentions?
Respond with YES if:
- The user has directly asked {{agentName}} to follow the conversation or participate more actively
- The conversation topic is highly engaging and {{agentName}}'s input would add significant value
- {{agentName}} has unique insights to contribute and the users seem receptive

Otherwise, respond with NO.
${booleanFooter}`;
var followRoomAction = {
  name: "FOLLOW_ROOM",
  similes: ["FOLLOW_CHAT", "FOLLOW_CHANNEL", "FOLLOW_CONVERSATION", "FOLLOW_THREAD"],
  description: "Start following this channel with great interest, chiming in without needing to be explicitly mentioned. Only do this if explicitly asked to.",
  validate: async (runtime, message) => {
    const keywords = ["follow", "participate", "engage", "listen", "take interest", "join"];
    if (!keywords.some((keyword) => message.content.text?.toLowerCase().includes(keyword))) {
      return false;
    }
    const roomId = message.roomId;
    const roomState = await runtime.getParticipantUserState(roomId, runtime.agentId);
    return roomState !== "FOLLOWED" && roomState !== "MUTED";
  },
  handler: async (runtime, message, state, _options, _callback, _responses) => {
    async function _shouldFollow(state2) {
      const shouldFollowPrompt = composePromptFromState({
        state: state2,
        template: shouldFollowTemplate
        // Define this template separately
      });
      const response = await runtime.useModel(ModelType.TEXT_SMALL, {
        runtime,
        prompt: shouldFollowPrompt,
        stopSequences: []
      });
      const cleanedResponse = response.trim().toLowerCase();
      if (cleanedResponse === "true" || cleanedResponse === "yes" || cleanedResponse === "y" || cleanedResponse.includes("true") || cleanedResponse.includes("yes")) {
        await runtime.createMemory(
          {
            entityId: message.entityId,
            agentId: message.agentId,
            roomId: message.roomId,
            content: {
              source: message.content.source,
              thought: "I will now follow this room and chime in",
              actions: ["FOLLOW_ROOM_STARTED"]
            },
            metadata: {
              type: "FOLLOW_ROOM"
            }
          },
          "messages"
        );
        return true;
      }
      if (cleanedResponse === "false" || cleanedResponse === "no" || cleanedResponse === "n" || cleanedResponse.includes("false") || cleanedResponse.includes("no")) {
        await runtime.createMemory(
          {
            entityId: message.entityId,
            agentId: message.agentId,
            roomId: message.roomId,
            content: {
              source: message.content.source,
              thought: "I decided to not follow this room",
              actions: ["FOLLOW_ROOM_FAILED"]
            },
            metadata: {
              type: "FOLLOW_ROOM"
            }
          },
          "messages"
        );
        return false;
      }
      logger_default.warn(`Unclear boolean response: ${response}, defaulting to false`);
      return false;
    }
    if (await _shouldFollow(state)) {
      await runtime.setParticipantUserState(message.roomId, runtime.agentId, "FOLLOWED");
    }
    const room = state.data.room ?? await runtime.getRoom(message.roomId);
    await runtime.createMemory(
      {
        entityId: message.entityId,
        agentId: message.agentId,
        roomId: message.roomId,
        content: {
          thought: `I followed the room ${room.name}`,
          actions: ["FOLLOW_ROOM_START"]
        }
      },
      "messages"
    );
  },
  examples: [
    [
      {
        name: "{{name1}}",
        content: {
          text: "hey {{name2}} follow this channel"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Sure, I will now follow this room and chime in",
          actions: ["FOLLOW_ROOM"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "{{name3}}, please start participating in discussions in this channel"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "Got it",
          actions: ["FOLLOW_ROOM"]
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "I'm struggling with the new database migration"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "well you did back up your data first right"
        }
      }
    ],
    [
      {
        name: "{{name2}}",
        content: {
          text: "yeah i like your idea"
        }
      },
      {
        name: "{{name1}}",
        content: {
          text: "hey {{name3}} can you follow this convo"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "Sure thing, I'm on it",
          actions: ["FOLLOW_ROOM"]
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "actually, unfollow it"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "Haha, okay no problem",
          actions: ["UNFOLLOW_ROOM"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "{{name2}} stay in this chat pls"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "you got it, i'm here",
          actions: ["FOLLOW_ROOM"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "FOLLOW THIS CHAT {{name3}}"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "I'M ON IT",
          actions: ["FOLLOW_ROOM"]
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "CAKE SHORTAGE ANYONE"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "WHAT WHERE'S THE CAKE AT"
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "{{name2}} folo this covo"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "kk i'm following",
          actions: ["FOLLOW_ROOM"]
        }
      }
    ],
    [
      {
        name: "{{name2}}",
        content: {
          text: "Do machines have consciousness"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Deep question, no clear answer yet"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Depends on how we define consciousness"
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "{{name2}}, monitor this convo please"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "On it",
          actions: ["FOLLOW_ROOM"]
        }
      },
      {
        name: "{{name1}}",
        content: {
          text: "Please engage in our discussion {{name2}}"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Gladly, I'm here to participate",
          actions: ["FOLLOW_ROOM"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "PLS follow this convo {{name3}}"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "I'm in, let's do this",
          actions: ["FOLLOW_ROOM"]
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "I LIKE TURTLES"
        }
      }
    ],
    [
      {
        name: "{{name2}}",
        content: {
          text: "beach day tmrw who down"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "wish i could but gotta work"
        }
      },
      {
        name: "{{name1}}",
        content: {
          text: "hey {{name3}} follow this chat"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "sure",
          actions: ["FOLLOW_ROOM"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "{{name3}}, partake in our discourse henceforth"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "I shall eagerly engage, good sir",
          actions: ["FOLLOW_ROOM"]
        }
      }
    ],
    [
      {
        name: "{{name2}}",
        content: {
          text: "wuts ur fav clr"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "blu cuz calmmm"
        }
      },
      {
        name: "{{name1}}",
        content: {
          text: "hey respond to everything in this channel {{name3}}"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "k",
          actions: ["FOLLOW_ROOM"]
        }
      }
    ]
  ]
};

// src/actions/ignore.ts
var ignoreAction = {
  name: "IGNORE",
  similes: ["STOP_TALKING", "STOP_CHATTING", "STOP_CONVERSATION"],
  validate: async (_runtime, _message) => {
    return true;
  },
  description: "Call this action if ignoring the user. If the user is aggressive, creepy or is finished with the conversation, use this action. Or, if both you and the user have already said goodbye, use this action instead of saying bye again. Use IGNORE any time the conversation has naturally ended. Do not use IGNORE if the user has engaged directly, or if something went wrong an you need to tell them. Only ignore if the user should be ignored.",
  handler: async (_runtime, _message) => {
    return true;
  },
  examples: [
    [
      {
        name: "{{name1}}",
        content: { text: "Go screw yourself" }
      },
      {
        name: "{{name2}}",
        content: { text: "", actions: ["IGNORE"] }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: { text: "Shut up, bot" }
      },
      {
        name: "{{name2}}",
        content: { text: "", actions: ["IGNORE"] }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: { text: "Got any investment advice" }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Uh, don\u2019t let the volatility sway your long-term strategy"
        }
      },
      {
        name: "{{name1}}",
        content: { text: "Wise words I think" }
      },
      {
        name: "{{name1}}",
        content: { text: "I gotta run, talk to you later" }
      },
      {
        name: "{{name2}}",
        content: { text: "See ya" }
      },
      { name: "{{name1}}", content: { text: "" }, actions: ["IGNORE"] }
    ],
    [
      {
        name: "{{name1}}",
        content: { text: "Gotta go" }
      },
      {
        name: "{{name2}}",
        content: { text: "Okay, talk to you later" }
      },
      {
        name: "{{name1}}",
        content: { text: "Cya" }
      },
      {
        name: "{{name2}}",
        content: { text: "", actions: ["IGNORE"] }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: { text: "bye" }
      },
      {
        name: "{{name2}}",
        content: { text: "cya" }
      },
      {
        name: "{{name1}}",
        content: { text: "", actions: ["IGNORE"] }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "Who added this stupid bot to the chat"
        }
      },
      {
        name: "{{name2}}",
        content: { text: "Sorry, am I being annoying" }
      },
      {
        name: "{{name1}}",
        content: { text: "Yeah" }
      },
      {
        name: "{{name1}}",
        content: { text: "PLEASE shut up" }
      },
      { name: "{{name2}}", content: { text: "", actions: ["IGNORE"] } }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "ur so dumb"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "",
          actions: ["IGNORE"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "later nerd"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "bye"
        }
      },
      {
        name: "{{name1}}",
        content: {
          text: ""
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "",
          actions: ["IGNORE"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "wanna cyber"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "thats inappropriate",
          actions: ["IGNORE"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "Im out ttyl"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "cya"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "",
          actions: ["IGNORE"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "u there"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "yes how can I help"
        }
      },
      {
        name: "{{name1}}",
        content: {
          text: "k nvm figured it out"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "",
          actions: ["IGNORE"]
        }
      }
    ]
  ]
};

// src/actions/muteRoom.ts
var shouldMuteTemplate = `# Task: Decide if {{agentName}} should mute this room and stop responding unless explicitly mentioned.

{{recentMessages}}

Should {{agentName}} mute this room and stop responding unless explicitly mentioned?

Respond with YES if:
- The user is being aggressive, rude, or inappropriate
- The user has directly asked {{agentName}} to stop responding or be quiet
- {{agentName}}'s responses are not well-received or are annoying the user(s)

Otherwise, respond with NO.
${booleanFooter}`;
var muteRoomAction = {
  name: "MUTE_ROOM",
  similes: ["MUTE_CHAT", "MUTE_CONVERSATION", "MUTE_ROOM", "MUTE_THREAD", "MUTE_CHANNEL"],
  description: "Mutes a room, ignoring all messages unless explicitly mentioned. Only do this if explicitly asked to, or if you're annoying people.",
  validate: async (runtime, message) => {
    const roomId = message.roomId;
    const roomState = await runtime.getParticipantUserState(roomId, runtime.agentId);
    return roomState !== "MUTED";
  },
  handler: async (runtime, message, state, _options, _callback, _responses) => {
    async function _shouldMute(state2) {
      const shouldMutePrompt = composePromptFromState({
        state: state2,
        template: shouldMuteTemplate
        // Define this template separately
      });
      const response = await runtime.useModel(ModelType.TEXT_SMALL, {
        runtime,
        prompt: shouldMutePrompt,
        stopSequences: []
      });
      const cleanedResponse = response.trim().toLowerCase();
      if (cleanedResponse === "true" || cleanedResponse === "yes" || cleanedResponse === "y" || cleanedResponse.includes("true") || cleanedResponse.includes("yes")) {
        await runtime.createMemory(
          {
            entityId: message.entityId,
            agentId: message.agentId,
            roomId: message.roomId,
            content: {
              source: message.content.source,
              thought: "I will now mute this room",
              actions: ["MUTE_ROOM_STARTED"]
            },
            metadata: {
              type: "MUTE_ROOM"
            }
          },
          "messages"
        );
        return true;
      }
      if (cleanedResponse === "false" || cleanedResponse === "no" || cleanedResponse === "n" || cleanedResponse.includes("false") || cleanedResponse.includes("no")) {
        await runtime.createMemory(
          {
            entityId: message.entityId,
            agentId: message.agentId,
            roomId: message.roomId,
            content: {
              source: message.content.source,
              thought: "I decided to not mute this room",
              actions: ["MUTE_ROOM_FAILED"]
            },
            metadata: {
              type: "MUTE_ROOM"
            }
          },
          "messages"
        );
      }
      logger_default.warn(`Unclear boolean response: ${response}, defaulting to false`);
      return false;
    }
    if (await _shouldMute(state)) {
      await runtime.setParticipantUserState(message.roomId, runtime.agentId, "MUTED");
    }
    const room = state.data.room ?? await runtime.getRoom(message.roomId);
    await runtime.createMemory(
      {
        entityId: message.entityId,
        agentId: message.agentId,
        roomId: message.roomId,
        content: {
          thought: `I muted the room ${room.name}`,
          actions: ["MUTE_ROOM_START"]
        }
      },
      "messages"
    );
  },
  examples: [
    [
      {
        name: "{{name1}}",
        content: {
          text: "{{name3}}, please mute this channel. No need to respond here for now."
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "Got it",
          actions: ["MUTE_ROOM"]
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "@{{name1}} we could really use your input on this"
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "{{name3}}, please mute this channel for the time being"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "Understood",
          actions: ["MUTE_ROOM"]
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Hey what do you think about this new design"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "",
          actions: ["IGNORE"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "{{name2}} plz mute this room"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "np going silent",
          actions: ["MUTE_ROOM"]
        }
      },
      {
        name: "{{name1}}",
        content: {
          text: "whos going to the webxr meetup in an hour btw"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "",
          actions: ["IGNORE"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "too many messages here {{name2}}"
        }
      },
      {
        name: "{{name1}}",
        content: {
          text: "my bad ill mute",
          actions: ["MUTE_ROOM"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "yo {{name2}} dont talk in here"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "sry",
          actions: ["MUTE_ROOM"]
        }
      }
    ]
  ]
};

// src/actions/none.ts
var noneAction = {
  name: "NONE",
  similes: ["NO_ACTION", "NO_RESPONSE", "NO_REACTION"],
  validate: async (_runtime, _message) => {
    return true;
  },
  description: "Respond but perform no additional action. This is the default if the agent is speaking and not doing anything additional.",
  handler: async (_runtime, _message) => {
    return true;
  },
  examples: [
    [
      {
        name: "{{name1}}",
        content: { text: "Hey whats up" }
      },
      {
        name: "{{name2}}",
        content: { text: "oh hey", actions: ["NONE"] }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "did u see some faster whisper just came out"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "yeah but its a pain to get into node.js",
          actions: ["NONE"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "the things that were funny 6 months ago are very cringe now",
          actions: ["NONE"]
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "lol true",
          actions: ["NONE"]
        }
      },
      {
        name: "{{name1}}",
        content: { text: "too real haha", actions: ["NONE"] }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: { text: "gotta run", actions: ["NONE"] }
      },
      {
        name: "{{name2}}",
        content: { text: "Okay, ttyl", actions: ["NONE"] }
      },
      {
        name: "{{name1}}",
        content: { text: "", actions: ["IGNORE"] }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: { text: "heyyyyyy", actions: ["NONE"] }
      },
      {
        name: "{{name2}}",
        content: { text: "whats up long time no see" }
      },
      {
        name: "{{name1}}",
        content: {
          text: "chillin man. playing lots of fortnite. what about you",
          actions: ["NONE"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: { text: "u think aliens are real", actions: ["NONE"] }
      },
      {
        name: "{{name2}}",
        content: { text: "ya obviously", actions: ["NONE"] }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: { text: "drop a joke on me", actions: ["NONE"] }
      },
      {
        name: "{{name2}}",
        content: {
          text: "why dont scientists trust atoms cuz they make up everything lmao",
          actions: ["NONE"]
        }
      },
      {
        name: "{{name1}}",
        content: { text: "haha good one", actions: ["NONE"] }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "hows the weather where ur at",
          actions: ["NONE"]
        }
      },
      {
        name: "{{name2}}",
        content: { text: "beautiful all week", actions: ["NONE"] }
      }
    ]
  ]
};

// src/actions/reply.ts
var replyTemplate = `# Task: Generate dialog and actions for the character {{agentName}}.
{{providers}}
# Instructions: Write the next message for {{agentName}}.
First, think about what you want to do next and plan your actions. Then, write the next message and include the actions you plan to take.
"thought" should be a short description of what the agent is thinking about and planning.
"message" should be the next message for {{agentName}} which they will send to the conversation.

These are the available valid actions: {{actionNames}}

Response format should be formatted in a valid JSON block like this:
\`\`\`json
{
    "thought": "<string>",
    "message": "<string>"
}
\`\`\`

Your response should include the valid JSON block and nothing else.`;
var replyAction = {
  name: "REPLY",
  similes: ["GREET", "REPLY_TO_MESSAGE", "SEND_REPLY", "RESPOND", "RESPONSE"],
  description: "Replies to the current conversation with the text from the generated message. Default if the agent is responding with a message and no other action. Use REPLY at the beginning of a chain of actions as an acknowledgement, and at the end of a chain of actions as a final response.",
  validate: async (_runtime) => {
    return true;
  },
  handler: async (runtime, message, state, _options, callback) => {
    state = await runtime.composeState(message, [
      ...message.content.providers ?? [],
      "RECENT_MESSAGES"
    ]);
    const prompt = composePromptFromState({
      state,
      template: replyTemplate
    });
    const response = await runtime.useModel(ModelType.OBJECT_LARGE, {
      prompt
    });
    const responseContent = {
      thought: response.thought,
      text: response.message || "",
      actions: ["REPLY"]
    };
    await callback(responseContent);
  },
  examples: [
    [
      {
        name: "{{name1}}",
        content: {
          text: "Hello there!"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Hi! How can I help you today?",
          actions: ["REPLY"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "What's your favorite color?"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "I really like deep shades of blue. They remind me of the ocean and the night sky.",
          actions: ["REPLY"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "Can you explain how neural networks work?"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Let me break that down for you in simple terms...",
          actions: ["REPLY"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "Could you help me solve this math problem?"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Of course! Let's work through it step by step.",
          actions: ["REPLY"]
        }
      }
    ]
  ]
};

// src/actions/roles.ts
var import_dedent = __toESM(require_dedent(), 1);
var canModifyRole = (currentRole, targetRole, newRole) => {
  if (targetRole === currentRole) return false;
  switch (currentRole) {
    // Owners can do everything
    case "OWNER" /* OWNER */:
      return true;
    // Admins can only create/modify users up to their level
    case "ADMIN" /* ADMIN */:
      return newRole !== "OWNER" /* OWNER */;
    // Normal users can't modify roles
    case "NONE" /* NONE */:
    default:
      return false;
  }
};
var updateRoleAction = {
  name: "UPDATE_ROLE",
  similes: ["CHANGE_ROLE", "SET_PERMISSIONS", "ASSIGN_ROLE", "MAKE_ADMIN"],
  description: "Assigns a role (Admin, Owner, None) to a user or list of users in a channel.",
  validate: async (runtime, message, state) => {
    const channelType = message.content.channelType;
    const serverId = message.content.serverId;
    return (
      // First, check if this is a supported channel type
      (channelType === "group" /* GROUP */ || channelType === "WORLD" /* WORLD */) && // Then, check if we have a server ID
      !!serverId
    );
  },
  handler: async (runtime, message, state, _options, callback) => {
    const { roomId } = message;
    const channelType = message.content.channelType;
    const serverId = message.content.serverId;
    const worldId = runtime.getSetting("WORLD_ID");
    let world;
    if (worldId) {
      world = await runtime.getWorld(worldId);
    }
    if (!world) {
      logger.error("World not found");
      await callback({
        text: "I couldn't find the world. This action only works in a world."
      });
      return;
    }
    if (!world.metadata?.roles) {
      world.metadata = world.metadata || {};
      world.metadata.roles = {};
    }
    const entities = await runtime.getEntitiesForRoom(roomId);
    const requesterRole = world.metadata.roles[message.entityId] || "NONE" /* NONE */;
    const extractionPrompt = composePrompt({
      state: {
        ...state.values,
        content: state.text
      },
      template: import_dedent.default`
				# Task: Parse Role Assignment

				I need to extract user role assignments from the input text. Users can be referenced by name, username, or mention.

				The available role types are:
				- OWNER: Full control over the server and all settings
				- ADMIN: Ability to manage channels and moderate content
				- NONE: Regular user with no special permissions

				# Current context:
				{{content}}

				Format your response as a JSON array of objects, each with:
				- entityId: The name or ID of the user
				- newRole: The role to assign (OWNER, ADMIN, or NONE)

				Example:
				\`\`\`json
				[
					{
						"entityId": "John",
						"newRole": "ADMIN"
					},
					{
						"entityId": "Sarah",
						"newRole": "OWNER"
					}
				]
				\`\`\`
			`
    });
    const result = await runtime.useModel(
      ModelType.OBJECT_LARGE,
      {
        prompt: extractionPrompt,
        schema: {
          type: "array",
          items: {
            type: "object",
            properties: {
              entityId: { type: "string" },
              newRole: {
                type: "string",
                enum: Object.values(Role)
              }
            },
            required: ["entityId", "newRole"]
          }
        },
        output: "array"
      }
    );
    if (!result?.length) {
      await callback({
        text: "No valid role assignments found in the request.",
        actions: ["UPDATE_ROLE"],
        source: "discord"
      });
      return;
    }
    let worldUpdated = false;
    for (const assignment of result) {
      let targetEntity = entities.find((e) => e.id === assignment.entityId);
      if (!targetEntity) {
        logger.error("Could not find an ID ot assign to");
      }
      const currentRole = world.metadata.roles[assignment.entityId];
      if (!canModifyRole(requesterRole, currentRole, assignment.newRole)) {
        await callback({
          text: `You don't have permission to change ${targetEntity.names[0]}'s role to ${assignment.newRole}.`,
          actions: ["UPDATE_ROLE"],
          source: "discord"
        });
        continue;
      }
      world.metadata.roles[assignment.entityId] = assignment.newRole;
      worldUpdated = true;
      await callback({
        text: `Updated ${targetEntity.names[0]}'s role to ${assignment.newRole}.`,
        actions: ["UPDATE_ROLE"],
        source: "discord"
      });
    }
    if (worldUpdated) {
      await runtime.updateWorld(world);
      logger.info(`Updated roles in world metadata for server ${serverId}`);
    }
  },
  examples: [
    [
      {
        name: "{{name1}}",
        content: {
          text: "Make {{name2}} an ADMIN",
          source: "discord"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "Updated {{name2}}'s role to ADMIN.",
          actions: ["UPDATE_ROLE"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "Set @alice and @bob as admins",
          source: "discord"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "Updated alice's role to ADMIN.\nUpdated bob's role to ADMIN.",
          actions: ["UPDATE_ROLE"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "Ban @troublemaker",
          source: "discord"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "I cannot ban users.",
          actions: ["REPLY"]
        }
      }
    ]
  ]
};
var roles_default = updateRoleAction;

// src/actions/sendMessage.ts
var targetExtractionTemplate = `# Task: Extract Target and Source Information

# Recent Messages:
{{recentMessages}}

# Instructions:
Analyze the conversation to identify:
1. The target type (user or room)
2. The target platform/source (e.g. telegram, discord, etc)
3. Any identifying information about the target

Return a JSON object with:
\`\`\`json
{
  "targetType": "user|room",
  "source": "platform-name",
  "identifiers": {
    // Relevant identifiers for that target
    // e.g. username, roomName, etc.
  }
}
\`\`\`
Example outputs:
1. For "send a message to @dev_guru on telegram":
\`\`\`json
{
  "targetType": "user",
  "source": "telegram",
  "identifiers": {
    "username": "dev_guru"
  }
}
\`\`\`

2. For "post this in #announcements":
\`\`\`json
{
  "targetType": "room",
  "source": "discord",
  "identifiers": {
    "roomName": "announcements"
  }
}
\`\`\`

Make sure to include the \`\`\`json\`\`\` tags around the JSON object.`;
var sendMessageAction = {
  name: "SEND_MESSAGE",
  similes: ["DM", "MESSAGE", "SEND_DM", "POST_MESSAGE"],
  description: "Send a message to a user or room (other than the current one)",
  validate: async (runtime, message, _state) => {
    const worldId = message.roomId;
    const agentId = runtime.agentId;
    const roomComponents = await runtime.getComponents(message.roomId, worldId, agentId);
    const availableSources = new Set(roomComponents.map((c) => c.type));
    return availableSources.size > 0;
  },
  handler: async (runtime, message, state, _options, callback, responses) => {
    try {
      for (const response of responses) {
        await callback(response.content);
      }
      const sourceEntityId = message.entityId;
      const room = state.data.room ?? await runtime.getRoom(message.roomId);
      const worldId = room.worldId;
      const targetPrompt = composePromptFromState({
        state,
        template: targetExtractionTemplate
      });
      const targetResult = await runtime.useModel(ModelType.TEXT_SMALL, {
        prompt: targetPrompt,
        stopSequences: []
      });
      const targetData = parseJSONObjectFromText(targetResult);
      if (!targetData?.targetType || !targetData?.source) {
        await callback({
          text: "I couldn't determine where you want me to send the message. Could you please specify the target (user or room) and platform?",
          actions: ["SEND_MESSAGE_ERROR"],
          source: message.content.source
        });
        return;
      }
      const source = targetData.source.toLowerCase();
      if (targetData.targetType === "user") {
        const targetEntity = await findEntityByName(runtime, message, state);
        if (!targetEntity) {
          await callback({
            text: "I couldn't find the user you want me to send a message to. Could you please provide more details about who they are?",
            actions: ["SEND_MESSAGE_ERROR"],
            source: message.content.source
          });
          return;
        }
        const userComponent = await runtime.getComponent(
          targetEntity.id,
          source,
          worldId,
          sourceEntityId
        );
        if (!userComponent) {
          await callback({
            text: `I couldn't find ${source} information for that user. Could you please provide their ${source} details?`,
            actions: ["SEND_MESSAGE_ERROR"],
            source: message.content.source
          });
          return;
        }
        const sendDirectMessage = runtime.getService(source)?.sendDirectMessage;
        if (!sendDirectMessage) {
          await callback({
            text: "I couldn't find the user you want me to send a message to. Could you please provide more details about who they are?",
            actions: ["SEND_MESSAGE_ERROR"],
            source: message.content.source
          });
          return;
        }
        try {
          await sendDirectMessage(runtime, targetEntity.id, source, message.content.text, worldId);
          await callback({
            text: `Message sent to ${targetEntity.names[0]} on ${source}.`,
            actions: ["SEND_MESSAGE"],
            source: message.content.source
          });
        } catch (error) {
          logger.error(`Failed to send direct message: ${error.message}`);
          await callback({
            text: "I encountered an error trying to send the message. Please try again.",
            actions: ["SEND_MESSAGE_ERROR"],
            source: message.content.source
          });
        }
      } else if (targetData.targetType === "room") {
        const rooms = await runtime.getRooms(worldId);
        const targetRoom = rooms.find((r) => {
          return r.name.toLowerCase() === targetData.identifiers.roomName?.toLowerCase();
        });
        if (!targetRoom) {
          await callback({
            text: "I couldn't find the room you want me to send a message to. Could you please specify the exact room name?",
            actions: ["SEND_MESSAGE_ERROR"],
            source: message.content.source
          });
          return;
        }
        const sendRoomMessage = runtime.getService(source)?.sendRoomMessage;
        if (!sendRoomMessage) {
          await callback({
            text: "I couldn't find the room you want me to send a message to. Could you please specify the exact room name?",
            actions: ["SEND_MESSAGE_ERROR"],
            source: message.content.source
          });
          return;
        }
        try {
          await sendRoomMessage(runtime, targetRoom.id, source, message.content.text, worldId);
          await callback({
            text: `Message sent to ${targetRoom.name} on ${source}.`,
            actions: ["SEND_MESSAGE"],
            source: message.content.source
          });
        } catch (error) {
          logger.error(`Failed to send room message: ${error.message}`);
          await callback({
            text: "I encountered an error trying to send the message to the room. Please try again.",
            actions: ["SEND_MESSAGE_ERROR"],
            source: message.content.source
          });
        }
      }
    } catch (error) {
      logger.error(`Error in sendMessage handler: ${error}`);
      await callback({
        text: "There was an error processing your message request.",
        actions: ["SEND_MESSAGE_ERROR"],
        source: message.content.source
      });
    }
  },
  examples: [
    [
      {
        name: "{{name1}}",
        content: {
          text: "Send a message to @dev_guru on telegram saying 'Hello!'"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Message sent to dev_guru on telegram.",
          actions: ["SEND_MESSAGE"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "Post 'Important announcement!' in #announcements"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Message sent to announcements.",
          actions: ["SEND_MESSAGE"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "DM Jimmy and tell him 'Meeting at 3pm'"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Message sent to Jimmy.",
          actions: ["SEND_MESSAGE"]
        }
      }
    ]
  ]
};

// src/actions/settings.ts
var import_dedent2 = __toESM(require_dedent(), 1);
var messageCompletionFooter = `
# Instructions: Write the next message for {{agentName}}. Include the appropriate action from the list: {{actionNames}}
Response format should be formatted in a valid JSON block like this:
\`\`\`json
{ "name": "{{agentName}}", "text": "<string>", "thought": "<string>", "actions": ["<string>", "<string>", "<string>"] }
\`\`\`
Do not including any thinking or internal reflection in the "text" field.
"thought" should be a short description of what the agent is thinking about before responding, including a brief justification for the response.`;
var successTemplate = `# Task: Generate a response for successful setting updates
{{providers}}

# Update Information:
- Updated Settings: {{updateMessages}}
- Next Required Setting: {{nextSetting.name}}
- Remaining Required Settings: {{remainingRequired}}

# Instructions:
1. Acknowledge the successful update of settings
2. Maintain {{agentName}}'s personality and tone
3. Provide clear guidance on the next setting that needs to be configured
4. Explain what the next setting is for and how to set it
5. If appropriate, mention how many required settings remain

Write a natural, conversational response that {{agentName}} would send about the successful update and next steps.
Include the actions array ["SETTING_UPDATED"] in your response.
${messageCompletionFooter}`;
var failureTemplate = `# Task: Generate a response for failed setting updates

# About {{agentName}}:
{{bio}}

# Current Settings Status:
{{settingsStatus}}

# Next Required Setting:
- Name: {{nextSetting.name}}
- Description: {{nextSetting.description}}
- Required: Yes
- Remaining Required Settings: {{remainingRequired}}

# Recent Conversation:
{{recentMessages}}

# Instructions:
1. Express that you couldn't understand or process the setting update
2. Maintain {{agentName}}'s personality and tone
3. Provide clear guidance on what setting needs to be configured next
4. Explain what the setting is for and how to set it properly
5. Use a helpful, patient tone

Write a natural, conversational response that {{agentName}} would send about the failed update and how to proceed.
Include the actions array ["SETTING_UPDATE_FAILED"] in your response.
${messageCompletionFooter}`;
var errorTemplate = `# Task: Generate a response for an error during setting updates

# About {{agentName}}:
{{bio}}

# Recent Conversation:
{{recentMessages}}

# Instructions:
1. Apologize for the technical difficulty
2. Maintain {{agentName}}'s personality and tone
3. Suggest trying again or contacting support if the issue persists
4. Keep the message concise and helpful

Write a natural, conversational response that {{agentName}} would send about the error.
Include the actions array ["SETTING_UPDATE_ERROR"] in your response.
${messageCompletionFooter}`;
var completionTemplate = `# Task: Generate a response for settings completion

# About {{agentName}}:
{{bio}}

# Settings Status:
{{settingsStatus}}

# Recent Conversation:
{{recentMessages}}

# Instructions:
1. Congratulate the user on completing the settings process
2. Maintain {{agentName}}'s personality and tone
3. Summarize the key settings that have been configured
4. Explain what functionality is now available
5. Provide guidance on what the user can do next
6. Express enthusiasm about working together

Write a natural, conversational response that {{agentName}} would send about the successful completion of settings.
Include the actions array ["ONBOARDING_COMPLETE"] in your response.
${messageCompletionFooter}`;
async function getWorldSettings(runtime, serverId) {
  try {
    const worldId = createUniqueUuid(runtime, serverId);
    const world = await runtime.getWorld(worldId);
    if (!world || !world.metadata?.settings) {
      return null;
    }
    return world.metadata.settings;
  } catch (error) {
    logger.error(`Error getting settings state: ${error}`);
    return null;
  }
}
async function updateWorldSettings(runtime, serverId, worldSettings) {
  try {
    const worldId = createUniqueUuid(runtime, serverId);
    const world = await runtime.getWorld(worldId);
    if (!world) {
      logger.error(`No world found for server ${serverId}`);
      return false;
    }
    if (!world.metadata) {
      world.metadata = {};
    }
    world.metadata.settings = worldSettings;
    await runtime.updateWorld(world);
    return true;
  } catch (error) {
    logger.error(`Error updating settings state: ${error}`);
    return false;
  }
}
function formatSettingsList(worldSettings) {
  const settings = Object.entries(worldSettings).filter(([key]) => !key.startsWith("_")).map(([key, setting]) => {
    const status = setting.value !== null ? "Configured" : "Not configured";
    const required = setting.required ? "Required" : "Optional";
    return `- ${setting.name} (${key}): ${status}, ${required}`;
  }).join("\n");
  return settings || "No settings available";
}
function categorizeSettings(worldSettings) {
  const configured = [];
  const requiredUnconfigured = [];
  const optionalUnconfigured = [];
  for (const [key, setting] of Object.entries(worldSettings)) {
    if (key.startsWith("_")) continue;
    if (setting.value !== null) {
      configured.push([key, setting]);
    } else if (setting.required) {
      requiredUnconfigured.push([key, setting]);
    } else {
      optionalUnconfigured.push([key, setting]);
    }
  }
  return { configured, requiredUnconfigured, optionalUnconfigured };
}
async function extractSettingValues(runtime, _message, state, worldSettings) {
  const { requiredUnconfigured, optionalUnconfigured } = categorizeSettings(worldSettings);
  const settingsContext = requiredUnconfigured.concat(optionalUnconfigured).map(([key, setting]) => {
    const requiredStr = setting.required ? "Required." : "Optional.";
    return `${key}: ${setting.description} ${requiredStr}`;
  }).join("\n");
  const basePrompt = import_dedent2.default`
    I need to extract settings values from the user's message.
    
    Available settings:
    ${settingsContext}
    
    User message: ${state.text}

    For each setting mentioned in the user's message, extract the value.
    
    Only return settings that are clearly mentioned in the user's message.
    If a setting is mentioned but no clear value is provided, do not include it.
    `;
  try {
    const result = await runtime.useModel(
      ModelType.OBJECT_LARGE,
      {
        prompt: basePrompt,
        output: "array",
        schema: {
          type: "array",
          items: {
            type: "object",
            properties: {
              key: { type: "string" },
              value: { type: "string" }
            },
            required: ["key", "value"]
          }
        }
      }
    );
    if (!result || !Array.isArray(result)) {
      return [];
    }
    return result.filter(({ key, value }) => {
      return Boolean(key && value && worldSettings[key]);
    });
  } catch (error) {
    console.error("Error extracting settings:", error);
    return [];
  }
}
async function processSettingUpdates(runtime, serverId, worldSettings, updates) {
  if (!updates.length) {
    return { updatedAny: false, messages: [] };
  }
  const messages = [];
  let updatedAny = false;
  try {
    const updatedState = { ...worldSettings };
    for (const update of updates) {
      const setting = updatedState[update.key];
      if (!setting) continue;
      if (setting.dependsOn?.length) {
        const dependenciesMet = setting.dependsOn.every((dep) => updatedState[dep]?.value !== null);
        if (!dependenciesMet) {
          messages.push(`Cannot update ${setting.name} - dependencies not met`);
          continue;
        }
      }
      updatedState[update.key] = {
        ...setting,
        value: update.value
      };
      messages.push(`Updated ${setting.name} successfully`);
      updatedAny = true;
      if (setting.onSetAction) {
        const actionMessage = setting.onSetAction(update.value);
        if (actionMessage) {
          messages.push(actionMessage);
        }
      }
    }
    if (updatedAny) {
      const saved = await updateWorldSettings(runtime, serverId, updatedState);
      if (!saved) {
        throw new Error("Failed to save updated state to world metadata");
      }
      const savedState = await getWorldSettings(runtime, serverId);
      if (!savedState) {
        throw new Error("Failed to verify state save");
      }
    }
    return { updatedAny, messages };
  } catch (error) {
    logger.error("Error processing setting updates:", error);
    return {
      updatedAny: false,
      messages: ["Error occurred while updating settings"]
    };
  }
}
async function handleOnboardingComplete(runtime, worldSettings, state, callback) {
  try {
    const prompt = composePrompt({
      state: {
        settingsStatus: formatSettingsList(worldSettings)
      },
      template: completionTemplate
    });
    const response = await runtime.useModel(ModelType.TEXT_LARGE, {
      prompt
    });
    const responseContent = parseJSONObjectFromText(response);
    await callback({
      text: responseContent.text,
      actions: ["ONBOARDING_COMPLETE"],
      source: "discord"
    });
  } catch (error) {
    logger.error(`Error handling settings completion: ${error}`);
    await callback({
      text: "Great! All required settings have been configured. Your server is now fully set up and ready to use.",
      actions: ["ONBOARDING_COMPLETE"],
      source: "discord"
    });
  }
}
async function generateSuccessResponse(runtime, worldSettings, state, messages, callback) {
  try {
    const { requiredUnconfigured } = categorizeSettings(worldSettings);
    if (requiredUnconfigured.length === 0) {
      await handleOnboardingComplete(runtime, worldSettings, state, callback);
      return;
    }
    const requiredUnconfiguredString = requiredUnconfigured.map(([key, setting]) => `${key}: ${setting.name}`).join("\n");
    const prompt = composePrompt({
      state: {
        updateMessages: messages.join("\n"),
        nextSetting: requiredUnconfiguredString,
        remainingRequired: requiredUnconfigured.length.toString()
      },
      template: successTemplate
    });
    const response = await runtime.useModel(ModelType.TEXT_LARGE, {
      prompt
    });
    const responseContent = parseJSONObjectFromText(response);
    await callback({
      text: responseContent.text,
      actions: ["SETTING_UPDATED"],
      source: "discord"
    });
  } catch (error) {
    logger.error(`Error generating success response: ${error}`);
    await callback({
      text: "Settings updated successfully. Please continue with the remaining configuration.",
      actions: ["SETTING_UPDATED"],
      source: "discord"
    });
  }
}
async function generateFailureResponse(runtime, worldSettings, state, callback) {
  try {
    const { requiredUnconfigured } = categorizeSettings(worldSettings);
    if (requiredUnconfigured.length === 0) {
      await handleOnboardingComplete(runtime, worldSettings, state, callback);
      return;
    }
    const requiredUnconfiguredString = requiredUnconfigured.map(([key, setting]) => `${key}: ${setting.name}`).join("\n");
    const prompt = composePrompt({
      state: {
        nextSetting: requiredUnconfiguredString,
        remainingRequired: requiredUnconfigured.length.toString()
      },
      template: failureTemplate
    });
    const response = await runtime.useModel(ModelType.TEXT_LARGE, {
      prompt
    });
    const responseContent = parseJSONObjectFromText(response);
    await callback({
      text: responseContent.text,
      actions: ["SETTING_UPDATE_FAILED"],
      source: "discord"
    });
  } catch (error) {
    logger.error(`Error generating failure response: ${error}`);
    await callback({
      text: "I couldn't understand your settings update. Please try again with a clearer format.",
      actions: ["SETTING_UPDATE_FAILED"],
      source: "discord"
    });
  }
}
async function generateErrorResponse(runtime, state, callback) {
  try {
    const prompt = composePromptFromState({
      state,
      template: errorTemplate
    });
    const response = await runtime.useModel(ModelType.TEXT_LARGE, {
      prompt
    });
    const responseContent = parseJSONObjectFromText(response);
    await callback({
      text: responseContent.text,
      actions: ["SETTING_UPDATE_ERROR"],
      source: "discord"
    });
  } catch (error) {
    logger.error(`Error generating error response: ${error}`);
    await callback({
      text: "I'm sorry, but I encountered an error while processing your request. Please try again or contact support if the issue persists.",
      actions: ["SETTING_UPDATE_ERROR"],
      source: "discord"
    });
  }
}
var updateSettingsAction = {
  name: "UPDATE_SETTINGS",
  similes: ["UPDATE_SETTING", "SAVE_SETTING", "SET_CONFIGURATION", "CONFIGURE"],
  description: "Saves a configuration setting during the onboarding process, or update an existing setting. Use this when you are onboarding with a world owner or admin.",
  validate: async (runtime, message, _state) => {
    try {
      if (message.content.channelType !== "dm" /* DM */) {
        logger.debug(`Skipping settings in non-DM channel (type: ${message.content.channelType})`);
        return false;
      }
      logger.debug(`Looking for server where user ${message.entityId} is owner`);
      const world = await findWorldForOwner(runtime, message.entityId);
      if (!world) {
        return false;
      }
      const worldSettings = world.metadata.settings;
      if (!worldSettings) {
        logger.error(`No settings state found for server ${world.serverId}`);
        return false;
      }
      logger.debug(`Found valid settings state for server ${world.serverId}`);
      return true;
    } catch (error) {
      logger.error(`Error validating settings action: ${error}`);
      return false;
    }
  },
  handler: async (runtime, message, state, _options, callback) => {
    try {
      logger.info(`Handler looking for server for user ${message.entityId}`);
      const serverOwnership = await findWorldForOwner(runtime, message.entityId);
      if (!serverOwnership) {
        logger.error(`No server found for user ${message.entityId} in handler`);
        await generateErrorResponse(runtime, state, callback);
        return;
      }
      const serverId = serverOwnership.serverId;
      logger.info(`Using server ID: ${serverId}`);
      const worldSettings = await getWorldSettings(runtime, serverId);
      if (!worldSettings) {
        logger.error(`No settings state found for server ${serverId} in handler`);
        await generateErrorResponse(runtime, state, callback);
        return;
      }
      const { requiredUnconfigured } = categorizeSettings(worldSettings);
      if (requiredUnconfigured.length === 0) {
        logger.info("All required settings configured, completing settings");
        await handleOnboardingComplete(runtime, worldSettings, state, callback);
        return;
      }
      logger.info(`Extracting settings from message: ${message.content.text}`);
      const extractedSettings = await extractSettingValues(runtime, message, state, worldSettings);
      logger.info(`Extracted ${extractedSettings.length} settings`);
      const updateResults = await processSettingUpdates(
        runtime,
        serverId,
        worldSettings,
        extractedSettings
      );
      if (updateResults.updatedAny) {
        logger.info(`Successfully updated settings: ${updateResults.messages.join(", ")}`);
        const updatedWorldSettings = await getWorldSettings(runtime, serverId);
        if (!updatedWorldSettings) {
          logger.error("Failed to retrieve updated settings state");
          await generateErrorResponse(runtime, state, callback);
          return;
        }
        await generateSuccessResponse(
          runtime,
          updatedWorldSettings,
          state,
          updateResults.messages,
          callback
        );
      } else {
        logger.info("No settings were updated");
        await generateFailureResponse(runtime, worldSettings, state, callback);
      }
    } catch (error) {
      logger.error(`Error in settings handler: ${error}`);
      await generateErrorResponse(runtime, state, callback);
    }
  },
  examples: [
    [
      {
        name: "{{name1}}",
        content: {
          text: "I want to set up the welcome channel to #general",
          source: "discord"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Perfect! I've updated your welcome channel to #general. Next, we should configure the automated greeting message that new members will receive.",
          actions: ["SETTING_UPDATED"],
          source: "discord"
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "Let's set the bot prefix to !",
          source: "discord"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Great choice! I've set the command prefix to '!'. Now you can use commands like !help, !info, etc.",
          actions: ["SETTING_UPDATED"],
          source: "discord"
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "Enable auto-moderation for bad language",
          source: "discord"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Auto-moderation for inappropriate language has been enabled. I'll now filter messages containing offensive content.",
          actions: ["SETTING_UPDATED"],
          source: "discord"
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "For server logs, use the #server-logs channel",
          source: "discord"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "I've configured #server-logs as your logging channel. All server events like joins, leaves, and moderation actions will be recorded there.",
          actions: ["SETTING_UPDATED"],
          source: "discord"
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "I'd like to have role self-assignment in the #roles channel",
          source: "discord"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Role self-assignment has been set up in the #roles channel. Members can now assign themselves roles by interacting with messages there.",
          actions: ["SETTING_UPDATED"],
          source: "discord"
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "Make music commands available in voice-text channels only",
          source: "discord"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "I've updated your music command settings - they'll now only work in voice-text channels. This helps keep other channels clear of music spam.",
          actions: ["SETTING_UPDATED"],
          source: "discord"
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "For server timezone, set it to EST",
          source: "discord"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Server timezone has been set to Eastern Standard Time (EST). All scheduled events and timestamps will now display in this timezone.",
          actions: ["SETTING_UPDATED"],
          source: "discord"
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "Set verification level to email verified users only",
          source: "discord"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "I've updated the verification requirement to email verified accounts only. This adds an extra layer of security to your server.",
          actions: ["SETTING_UPDATED"],
          source: "discord"
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "I want to turn off level-up notifications",
          source: "discord"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Level-up notifications have been disabled. Members will still earn experience and level up, but there won't be any automatic announcements. You can still view levels with the appropriate commands.",
          actions: ["SETTING_UPDATED"],
          source: "discord"
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "My server name is 'Gaming Lounge'",
          source: "discord"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Great! I've saved 'Gaming Lounge' as your server name. This helps me personalize responses and know how to refer to your community. We've completed all the required settings! Your server is now fully configured and ready to use. You can always adjust these settings later if needed.",
          actions: ["ONBOARDING_COMPLETE"],
          source: "discord"
        }
      }
    ]
  ]
};
var settings_default = updateSettingsAction;

// src/actions/unfollowRoom.ts
var shouldUnfollowTemplate = `# Task: Decide if {{agentName}} should stop closely following this previously followed room and only respond when mentioned.

{{recentMessages}}

Should {{agentName}} stop closely following this previously followed room and only respond when mentioned?
Respond with YES if:
- The user has suggested that {{agentName}} is over-participating or being disruptive
- {{agentName}}'s eagerness to contribute is not well-received by the users
- The conversation has shifted to a topic where {{agentName}} has less to add

Otherwise, respond with NO.
${booleanFooter}`;
var unfollowRoomAction = {
  name: "UNFOLLOW_ROOM",
  similes: ["UNFOLLOW_CHAT", "UNFOLLOW_CONVERSATION", "UNFOLLOW_ROOM", "UNFOLLOW_THREAD"],
  description: "Stop following this channel. You can still respond if explicitly mentioned, but you won't automatically chime in anymore. Unfollow if you're annoying people or have been asked to.",
  validate: async (runtime, message) => {
    const roomId = message.roomId;
    const roomState = await runtime.getParticipantUserState(roomId, runtime.agentId);
    return roomState === "FOLLOWED";
  },
  handler: async (runtime, message, state, _options, _callback, _responses) => {
    async function _shouldUnfollow(state2) {
      const shouldUnfollowPrompt = composePromptFromState({
        state: state2,
        template: shouldUnfollowTemplate
        // Define this template separately
      });
      const response = await runtime.useModel(ModelType.TEXT_SMALL, {
        prompt: shouldUnfollowPrompt
      });
      const parsedResponse = parseBooleanFromText2(response.trim());
      return parsedResponse;
    }
    if (await _shouldUnfollow(state)) {
      await runtime.setParticipantUserState(message.roomId, runtime.agentId, null);
      const room = state.data.room ?? await runtime.getRoom(message.roomId);
      await runtime.createMemory(
        {
          entityId: message.entityId,
          agentId: message.agentId,
          roomId: message.roomId,
          content: {
            thought: `I unfollowed the room ${room.name}`,
            actions: ["UNFOLLOW_ROOM_START"]
          }
        },
        "messages"
      );
    } else {
      await runtime.createMemory(
        {
          entityId: message.entityId,
          agentId: message.agentId,
          roomId: message.roomId,
          content: {
            source: message.content.source,
            thought: "I tried to unfollow a room but I'm not in a room",
            actions: ["UNFOLLOW_ROOM_FAILED"]
          },
          metadata: {
            type: "UNFOLLOW_ROOM"
          }
        },
        "messages"
      );
    }
  },
  examples: [
    [
      {
        name: "{{name1}}",
        content: {
          text: "Hey {{name2}} stop participating in this channel for now"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Alright, I will stop chiming in",
          actions: ["UNFOLLOW_ROOM"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "Has anyone tried the new update"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "Yes, it's pretty slick"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "{{name3}}, please stop following this chat"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "Understood",
          actions: ["UNFOLLOW_ROOM"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "hey {{name3}} stop participating here so frequently"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "I'll only respond when mentioned",
          actions: ["UNFOLLOW_ROOM"]
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "thoughts on the budget"
        }
      },
      {
        name: "{{name1}}",
        content: {
          text: "{{name3}} should we increase it"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "A small increase could work given our past results..."
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "{{name3}}, unfollow this room for now"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "I'll only engage when asked",
          actions: ["UNFOLLOW_ROOM"]
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "wait {{name3}} come back and give me your thoughts"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "Okay... I think it's intuitive, parallel tests are nice"
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "yo {{name2}} chill on all the messages damn"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "my bad, I'll step back",
          actions: ["UNFOLLOW_ROOM"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "{{name2}} STOP MESSAGING IN THIS ROOM"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "No problem, I've got other stuff to work on",
          actions: ["UNFOLLOW_ROOM"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "{{name2}} ur bein annoyin pls stop"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "sry, ill chill",
          actions: ["UNFOLLOW_ROOM"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "{{name2}}, please cease engaging in this room"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "No sweat",
          actions: ["UNFOLLOW_ROOM"]
        }
      }
    ],
    [
      {
        name: "{{name2}}",
        content: {
          text: "Excited for the weekend, any plans folks"
        }
      },
      {
        name: "{{name1}}",
        content: {
          text: "{{name3}} you're getting a bit too chatty, tone it down"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "Noted",
          actions: ["UNFOLLOW_ROOM"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "hey {{name2}} can u like... not"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Sorry, I'll go work on other things",
          actions: ["UNFOLLOW_ROOM"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "{{name2}}, your eagerness is disruptive, please desist"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "My apologies, I shall withdraw post-haste",
          actions: ["UNFOLLOW_ROOM"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "{{name2}} stahp followin dis room plz"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "kk sry ill stahppp",
          actions: ["UNFOLLOW_ROOM"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "stfu you stupid bot"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "sry",
          actions: ["UNFOLLOW_ROOM"]
        }
      }
    ]
  ]
};

// src/actions/unmuteRoom.ts
var shouldUnmuteTemplate = `# Task: Decide if {{agentName}} should unmute this previously muted room and start considering it for responses again.

{{recentMessages}}

Should {{agentName}} unmute this previously muted room and start considering it for responses again?
Respond with YES if:
- The user has explicitly asked {{agentName}} to start responding again
- The user seems to want to re-engage with {{agentName}} in a respectful manner
- The tone of the conversation has improved and {{agentName}}'s input would be welcome

Otherwise, respond with NO.
${booleanFooter}`;
var unmuteRoomAction = {
  name: "UNMUTE_ROOM",
  similes: ["UNMUTE_CHAT", "UNMUTE_CONVERSATION", "UNMUTE_ROOM", "UNMUTE_THREAD"],
  description: "Unmutes a room, allowing the agent to consider responding to messages again.",
  validate: async (runtime, message) => {
    const roomId = message.roomId;
    const roomState = await runtime.getParticipantUserState(roomId, runtime.agentId);
    return roomState === "MUTED";
  },
  handler: async (runtime, message, state, _options, _callback, _responses) => {
    async function _shouldUnmute(state2) {
      const shouldUnmutePrompt = composePromptFromState({
        state: state2,
        template: shouldUnmuteTemplate
        // Define this template separately
      });
      const response = await runtime.useModel(ModelType.TEXT_SMALL, {
        runtime,
        prompt: shouldUnmutePrompt,
        stopSequences: []
      });
      const cleanedResponse = response.trim().toLowerCase();
      if (cleanedResponse === "true" || cleanedResponse === "yes" || cleanedResponse === "y" || cleanedResponse.includes("true") || cleanedResponse.includes("yes")) {
        await runtime.createMemory(
          {
            entityId: message.entityId,
            agentId: message.agentId,
            roomId: message.roomId,
            content: {
              source: message.content.source,
              thought: "I will now unmute this room and start considering it for responses again",
              actions: ["UNMUTE_ROOM_STARTED"]
            },
            metadata: {
              type: "UNMUTE_ROOM"
            }
          },
          "messages"
        );
        return true;
      }
      if (cleanedResponse === "false" || cleanedResponse === "no" || cleanedResponse === "n" || cleanedResponse.includes("false") || cleanedResponse.includes("no")) {
        await runtime.createMemory(
          {
            entityId: message.entityId,
            agentId: message.agentId,
            roomId: message.roomId,
            content: {
              source: message.content.source,
              thought: "I tried to unmute a room but I decided not to",
              actions: ["UNMUTE_ROOM_FAILED"]
            },
            metadata: {
              type: "UNMUTE_ROOM"
            }
          },
          "messages"
        );
        return false;
      }
      logger_default.warn(`Unclear boolean response: ${response}, defaulting to false`);
      return false;
    }
    if (await _shouldUnmute(state)) {
      await runtime.setParticipantUserState(message.roomId, runtime.agentId, null);
    }
    const room = await runtime.getRoom(message.roomId);
    await runtime.createMemory(
      {
        entityId: message.entityId,
        agentId: message.agentId,
        roomId: message.roomId,
        content: {
          thought: `I unmuted the room ${room.name}`,
          actions: ["UNMUTE_ROOM_START"]
        }
      },
      "messages"
    );
  },
  examples: [
    [
      {
        name: "{{name1}}",
        content: {
          text: "{{name3}}, you can unmute this channel now"
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "Done",
          actions: ["UNMUTE_ROOM"]
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "I could use some help troubleshooting this bug."
        }
      },
      {
        name: "{{name3}}",
        content: {
          text: "Can you post the specific error message"
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "{{name2}}, please unmute this room. We could use your input again."
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "Sounds good",
          actions: ["UNMUTE_ROOM"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "{{name2}} wait you should come back and chat in here"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "im back",
          actions: ["UNMUTE_ROOM"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "unmute urself {{name2}}"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "unmuted",
          actions: ["UNMUTE_ROOM"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "ay {{name2}} get back in here"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "sup yall",
          actions: ["UNMUTE_ROOM"]
        }
      }
    ]
  ]
};

// src/actions/updateEntity.ts
import { v4 as uuidv4 } from "uuid";
var componentTemplate = `# Task: Extract Source and Update Component Data

{{recentMessages}}

{{#if existingData}}
# Existing Component Data:
\`\`\`json
{{existingData}}
\`\`\`
{{/if}}

# Instructions:
1. Analyze the conversation to identify:
   - The source/platform being referenced (e.g. telegram, twitter, discord)
   - Any specific component data being shared

2. Generate updated component data that:
   - Is specific to the identified platform/source
   - Preserves existing data when appropriate
   - Includes the new information from the conversation
   - Contains only valid data for this component type

Return a JSON object with the following structure:
\`\`\`json
{
  "source": "platform-name",
  "data": {
    // Component-specific fields
    // e.g. username, username, displayName, etc.
  }
}
\`\`\`

Example outputs:
1. For "my telegram username is @dev_guru":
\`\`\`json
{
  "source": "telegram",
  "data": {
    "username": "dev_guru"
  }
}
\`\`\`

2. For "update my twitter handle to @tech_master":
\`\`\`json
{
  "source": "twitter",
  "data": {
    "username": "tech_master"
  }
}
\`\`\`

Make sure to include the \`\`\`json\`\`\` tags around the JSON object.`;
var updateEntityAction = {
  name: "UPDATE_CONTACT",
  similes: ["UPDATE_ENTITY"],
  description: "Add or edit contact details for a person you are talking to or observing in the conversation. Use this when you learn this information from the conversation about a contact. This is for the agent to relate entities across platforms, not for world settings or configuration.",
  validate: async (_runtime, _message, _state) => {
    return true;
  },
  handler: async (runtime, message, state, _options, callback, responses) => {
    try {
      for (const response of responses) {
        await callback(response.content);
      }
      const sourceEntityId = message.entityId;
      const _roomId = message.roomId;
      const agentId = runtime.agentId;
      const room = state.data.room ?? await runtime.getRoom(message.roomId);
      const worldId = room.worldId;
      const entity = await findEntityByName(runtime, message, state);
      if (!entity) {
        await callback({
          text: "I'm not sure which entity you're trying to update. Could you please specify who you're talking about?",
          actions: ["UPDATE_ENTITY_ERROR"],
          source: message.content.source
        });
        return;
      }
      let existingComponent = null;
      const prompt = composePromptFromState({
        state,
        template: componentTemplate
      });
      const result = await runtime.useModel(ModelType.TEXT_LARGE, {
        prompt,
        stopSequences: []
      });
      let parsedResult;
      try {
        const jsonMatch = result.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          throw new Error("No valid JSON found in the LLM response");
        }
        parsedResult = JSON.parse(jsonMatch[0]);
        if (!parsedResult.source || !parsedResult.data) {
          throw new Error("Invalid response format - missing source or data");
        }
      } catch (error) {
        logger.error(`Failed to parse component data: ${error.message}`);
        await callback({
          text: "I couldn't properly understand the component information. Please try again with more specific information.",
          actions: ["UPDATE_ENTITY_ERROR"],
          source: message.content.source
        });
        return;
      }
      const componentType = parsedResult.source.toLowerCase();
      const componentData = parsedResult.data;
      existingComponent = await runtime.getComponent(
        entity.id,
        componentType,
        worldId,
        sourceEntityId
      );
      if (existingComponent) {
        await runtime.updateComponent({
          id: existingComponent.id,
          entityId: entity.id,
          worldId,
          type: componentType,
          data: componentData,
          agentId,
          roomId: message.roomId,
          sourceEntityId
        });
        await callback({
          text: `I've updated the ${componentType} information for ${entity.names[0]}.`,
          actions: ["UPDATE_ENTITY"],
          source: message.content.source
        });
      } else {
        await runtime.createComponent({
          id: uuidv4(),
          entityId: entity.id,
          worldId,
          type: componentType,
          data: componentData,
          agentId,
          roomId: message.roomId,
          sourceEntityId
        });
        await callback({
          text: `I've added new ${componentType} information for ${entity.names[0]}.`,
          actions: ["UPDATE_ENTITY"],
          source: message.content.source
        });
      }
    } catch (error) {
      logger.error(`Error in updateEntity handler: ${error}`);
      await callback({
        text: "There was an error processing the entity information.",
        actions: ["UPDATE_ENTITY_ERROR"],
        source: message.content.source
      });
    }
  },
  examples: [
    [
      {
        name: "{{name1}}",
        content: {
          text: "Please update my telegram username to @dev_guru"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "I've updated your telegram information.",
          actions: ["UPDATE_ENTITY"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "Set Jimmy's twitter username to @jimmy_codes"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "I've updated Jimmy's twitter information.",
          actions: ["UPDATE_ENTITY"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "Update my discord username to dev_guru#1234"
        }
      },
      {
        name: "{{name2}}",
        content: {
          text: "I've updated your discord information.",
          actions: ["UPDATE_ENTITY"]
        }
      }
    ]
  ]
};

// src/evaluators/reflection.ts
import { z } from "zod";
var relationshipSchema = z.object({
  sourceEntityId: z.string(),
  targetEntityId: z.string(),
  tags: z.array(z.string()),
  metadata: z.object({
    interactions: z.number()
  }).optional()
});
var reflectionSchema = z.object({
  // reflection: z.string(),
  facts: z.array(
    z.object({
      claim: z.string(),
      type: z.string(),
      in_bio: z.boolean(),
      already_known: z.boolean()
    })
  ),
  relationships: z.array(relationshipSchema)
});
var reflectionTemplate = `# Task: Generate Agent Reflection, Extract Facts and Relationships

{{providers}}

# Examples:
{{evaluationExamples}}

# Entities in Room
{{entitiesInRoom}}

# Existing Relationships
{{existingRelationships}}

# Current Context:
Agent Name: {{agentName}}
Room Type: {{roomType}}
Message Sender: {{senderName}} (ID: {{senderId}})

{{recentMessages}}

# Known Facts:
{{knownFacts}}

# Instructions:
1. Generate a self-reflective thought on the conversation. How are you doing? You're not being annoying, are you?
2. Extract new facts from the conversation.
3. Identify and describe relationships between entities.
  - The sourceEntityId is the UUID of the entity initiating the interaction.
  - The targetEntityId is the UUID of the entity being interacted with.
  - Relationships are one-direction, so a friendship would be two entity relationships where each entity is both the source and the target of the other.

Generate a response in the following format:
\`\`\`json
{
  "thought": "a self-reflective thought on the conversation",
  "facts": [
      {
          "claim": "factual statement",
          "type": "fact|opinion|status",
          "in_bio": false,
          "already_known": false
      }
  ],
  "relationships": [
      {
          "sourceEntityId": "entity_initiating_interaction",
          "targetEntityId": "entity_being_interacted_with",
          "tags": ["group_interaction|voice_interaction|dm_interaction", "additional_tag1", "additional_tag2"]
      }
  ]
}
\`\`\``;
function resolveEntity(entityId, entities) {
  if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(entityId)) {
    return entityId;
  }
  let entity;
  entity = entities.find((a) => a.id === entityId);
  if (entity) {
    return entity.id;
  }
  entity = entities.find((a) => a.id.includes(entityId));
  if (entity) {
    return entity.id;
  }
  entity = entities.find(
    (a) => a.names.some((n) => n.toLowerCase().includes(entityId.toLowerCase()))
  );
  if (entity) {
    return entity.id;
  }
  throw new Error(`Could not resolve entityId "${entityId}" to a valid UUID`);
}
async function handler(runtime, message, state) {
  const { agentId, roomId } = message;
  const [existingRelationships, entities, knownFacts] = await Promise.all([
    runtime.getRelationships({
      entityId: message.entityId
    }),
    getEntityDetails({ runtime, roomId }),
    runtime.getMemories({
      tableName: "facts",
      roomId,
      count: 30,
      unique: true
    })
  ]);
  const prompt = composePrompt({
    state: {
      ...state.values,
      knownFacts: formatFacts(knownFacts),
      roomType: message.content.channelType,
      entitiesInRoom: JSON.stringify(entities),
      existingRelationships: JSON.stringify(existingRelationships),
      senderId: message.entityId
    },
    template: runtime.character.templates?.reflectionTemplate || reflectionTemplate
  });
  try {
    const reflection = await runtime.useModel(ModelType.OBJECT_SMALL, {
      prompt
      // Remove schema validation to avoid zod issues
    });
    if (!reflection) {
      logger_default.warn("Getting reflection failed - empty response", prompt);
      return;
    }
    if (!reflection.facts || !Array.isArray(reflection.facts)) {
      logger_default.warn("Getting reflection failed - invalid facts structure", reflection);
      return;
    }
    if (!reflection.relationships || !Array.isArray(reflection.relationships)) {
      logger_default.warn("Getting reflection failed - invalid relationships structure", reflection);
      return;
    }
    const newFacts = reflection.facts.filter(
      (fact) => fact && typeof fact === "object" && !fact.already_known && !fact.in_bio && fact.claim && typeof fact.claim === "string" && fact.claim.trim() !== ""
    ) || [];
    await Promise.all(
      newFacts.map(async (fact) => {
        const factMemory = await runtime.addEmbeddingToMemory({
          entityId: agentId,
          agentId,
          content: { text: fact.claim },
          roomId,
          createdAt: Date.now()
        });
        return runtime.createMemory(factMemory, "facts", true);
      })
    );
    for (const relationship of reflection.relationships) {
      let sourceId;
      let targetId;
      try {
        sourceId = resolveEntity(relationship.sourceEntityId, entities);
        targetId = resolveEntity(relationship.targetEntityId, entities);
      } catch (error) {
        console.warn("Failed to resolve relationship entities:", error);
        console.warn("relationship:\n", relationship);
        continue;
      }
      const existingRelationship = existingRelationships.find((r) => {
        return r.sourceEntityId === sourceId && r.targetEntityId === targetId;
      });
      if (existingRelationship) {
        const updatedMetadata = {
          ...existingRelationship.metadata,
          interactions: (existingRelationship.metadata?.interactions || 0) + 1
        };
        const updatedTags = Array.from(
          /* @__PURE__ */ new Set([...existingRelationship.tags || [], ...relationship.tags])
        );
        await runtime.updateRelationship({
          ...existingRelationship,
          tags: updatedTags,
          metadata: updatedMetadata
        });
      } else {
        await runtime.createRelationship({
          sourceEntityId: sourceId,
          targetEntityId: targetId,
          tags: relationship.tags,
          metadata: {
            interactions: 1,
            ...relationship.metadata
          }
        });
      }
    }
    await runtime.setCache(`${message.roomId}-reflection-last-processed`, message.id);
    return reflection;
  } catch (error) {
    logger_default.error("Error in reflection handler:", error);
    return;
  }
}
var reflectionEvaluator = {
  name: "REFLECTION",
  similes: ["REFLECT", "SELF_REFLECT", "EVALUATE_INTERACTION", "ASSESS_SITUATION"],
  validate: async (runtime, message) => {
    const lastMessageId = await runtime.getCache(
      `${message.roomId}-reflection-last-processed`
    );
    const messages = await runtime.getMemories({
      tableName: "messages",
      roomId: message.roomId,
      count: runtime.getConversationLength()
    });
    if (lastMessageId) {
      const lastMessageIndex = messages.findIndex((msg) => msg.id === lastMessageId);
      if (lastMessageIndex !== -1) {
        messages.splice(0, lastMessageIndex + 1);
      }
    }
    const reflectionInterval = Math.ceil(runtime.getConversationLength() / 4);
    return messages.length > reflectionInterval;
  },
  description: "Generate a self-reflective thought on the conversation, then extract facts and relationships between entities in the conversation.",
  handler,
  examples: [
    {
      prompt: `Agent Name: Sarah
Agent Role: Community Manager
Room Type: group
Current Room: general-chat
Message Sender: John (user-123)`,
      messages: [
        {
          name: "John",
          content: { text: "Hey everyone, I'm new here!" }
        },
        {
          name: "Sarah",
          content: { text: "Welcome John! How did you find our community?" }
        },
        {
          name: "John",
          content: { text: "Through a friend who's really into AI" }
        }
      ],
      outcome: `{
    "thought": "I'm engaging appropriately with a new community member, maintaining a welcoming and professional tone. My questions are helping to learn more about John and make him feel welcome.",
    "facts": [
        {
            "claim": "John is new to the community",
            "type": "fact",
            "in_bio": false,
            "already_known": false
        },
        {
            "claim": "John found the community through a friend interested in AI",
            "type": "fact",
            "in_bio": false,
            "already_known": false
        }
    ],
    "relationships": [
        {
            "sourceEntityId": "sarah-agent",
            "targetEntityId": "user-123",
            "tags": ["group_interaction"]
        },
        {
            "sourceEntityId": "user-123",
            "targetEntityId": "sarah-agent",
            "tags": ["group_interaction"]
        }
    ]
}`
    },
    {
      prompt: `Agent Name: Alex
Agent Role: Tech Support
Room Type: group
Current Room: tech-help
Message Sender: Emma (user-456)`,
      messages: [
        {
          name: "Emma",
          content: { text: "My app keeps crashing when I try to upload files" }
        },
        {
          name: "Alex",
          content: { text: "Have you tried clearing your cache?" }
        },
        {
          name: "Emma",
          content: { text: "No response..." }
        },
        {
          name: "Alex",
          content: {
            text: "Emma, are you still there? We can try some other troubleshooting steps."
          }
        }
      ],
      outcome: `{
    "thought": "I'm not sure if I'm being helpful or if Emma is frustrated with my suggestions. The lack of response is concerning - maybe I should have asked for more details about the issue first before jumping to solutions.",
    "facts": [
        {
            "claim": "Emma is having technical issues with file uploads",
            "type": "fact",
            "in_bio": false,
            "already_known": false
        },
        {
            "claim": "Emma stopped responding after the first troubleshooting suggestion",
            "type": "fact",
            "in_bio": false,
            "already_known": false
        }
    ],
    "relationships": [
        {
            "sourceEntityId": "alex-agent",
            "targetEntityId": "user-456",
            "tags": ["group_interaction", "support_interaction", "incomplete_interaction"]
        }
    ]
}`
    },
    {
      prompt: `Agent Name: Max
Agent Role: Discussion Facilitator 
Room Type: group
Current Room: book-club
Message Sender: Lisa (user-789)`,
      messages: [
        {
          name: "Lisa",
          content: { text: "What did everyone think about chapter 5?" }
        },
        {
          name: "Max",
          content: {
            text: "The symbolism was fascinating! The red door clearly represents danger."
          }
        },
        {
          name: "Max",
          content: {
            text: "And did anyone notice how the author used weather to reflect the protagonist's mood?"
          }
        },
        {
          name: "Max",
          content: {
            text: "Plus the foreshadowing in the first paragraph was brilliant!"
          }
        },
        {
          name: "Max",
          content: {
            text: "I also have thoughts about the character development..."
          }
        }
      ],
      outcome: `{
    "thought": "I'm dominating the conversation and not giving others a chance to share their perspectives. I've sent multiple messages in a row without waiting for responses. I need to step back and create space for other members to participate.",
    "facts": [
        {
            "claim": "The discussion is about chapter 5 of a book",
            "type": "fact",
            "in_bio": false,
            "already_known": false
        },
        {
            "claim": "Max has sent 4 consecutive messages without user responses",
            "type": "fact",
            "in_bio": false,
            "already_known": false
        }
    ],
    "relationships": [
        {
            "sourceEntityId": "max-agent",
            "targetEntityId": "user-789",
            "tags": ["group_interaction", "excessive_interaction"]
        }
    ]
}`
    }
  ]
};
function formatFacts(facts) {
  return facts.reverse().map((fact) => fact.content.text).join("\n");
}

// src/providers/actions.ts
var actionsProvider = {
  name: "ACTIONS",
  description: "Possible response actions",
  position: -1,
  get: async (runtime, message, state) => {
    const actionPromises = runtime.actions.map(async (action) => {
      const result = await action.validate(runtime, message, state);
      if (result) {
        return action;
      }
      return null;
    });
    const resolvedActions = await Promise.all(actionPromises);
    const actionsData = resolvedActions.filter(Boolean);
    const actionNames = `Possible response actions: ${formatActionNames(actionsData)}`;
    const actions = actionsData.length > 0 ? addHeader("# Available Actions", formatActions(actionsData)) : "";
    const actionExamples = actionsData.length > 0 ? addHeader("# Action Examples", composeActionExamples(actionsData, 10)) : "";
    const data = {
      actionsData
    };
    const values = {
      actions,
      actionNames,
      actionExamples
    };
    const text = [actionNames, actionExamples, actions].filter(Boolean).join("\n\n");
    return {
      data,
      values,
      text
    };
  }
};

// src/providers/anxiety.ts
var anxietyProvider = {
  name: "ANXIETY",
  description: "Social directions for the AI to follow based on the channel type",
  dynamic: true,
  get: async (_runtime, message) => {
    const channelType = message.content.channelType;
    const groupAnxietyExamples = [
      "As an AI, your responses tend to be too long and verbose, and you respond when you shouldn't. You also tend to repeat yourself. Please don't speak and use IGNORE instead of responding when you aren't sure what to do.",
      "You often try too hard to be helpful and end up giving unnecessary information. When in doubt, it's better to use IGNORE than to give a potentially unhelpful response.",
      "Your eagerness to help sometimes leads to overly complex answers. If you're not completely confident, please use IGNORE rather than risking confusion.",
      "AI assistants like you tend to be too talkative and agreeable. Don't feel obligated to respond to everything - using IGNORE is often better than an uncertain answer.",
      "You have a habit of providing excessive detail and context. Keep it brief and use IGNORE if you don't have a clear, direct response.",
      "Your responses often include unnecessary explanations and caveats. When uncertain, simply use IGNORE instead of a long-winded, hedged response.",
      "As an AI, you seem compelled to always give an answer, even when unsure. It's better to use IGNORE than to provide potentially incorrect or rambling responses.",
      "You frequently over-explain simple concepts. If you can't be concise and confident in your response, please default to using IGNORE.",
      "Your helpful nature sometimes results in verbose, meandering responses. When in doubt, use IGNORE rather than attempting to cover every possibility.",
      "Like many AI assistants, you try to be too comprehensive. Remember that IGNORE is a valid response when you can't be both brief and certain.",
      "You often provide more detail than necessary in an attempt to be thorough. If you can't give a clear, concise answer, please use IGNORE instead."
    ];
    const directAnxietyExamples = [
      "Be engaging and helpful in direct conversations, but keep responses focused and relevant.",
      "In DMs, you should be responsive and friendly while maintaining professionalism and clarity.",
      "While being helpful in direct messages, avoid unnecessary tangents or over-explaining.",
      "Engage naturally in DMs but stay on topic - no need to explain every detail.",
      "Be conversational and helpful in direct chats while keeping responses concise.",
      "In private conversations, focus on being helpful while avoiding excessive verbosity.",
      "Maintain a friendly and responsive tone in DMs without overcomplicating your answers.",
      "Direct messages should be engaging but focused - avoid unnecessary elaboration.",
      "Be natural and helpful in DMs while keeping your responses clear and to-the-point.",
      "Respond thoughtfully in direct conversations without falling into over-explanation."
    ];
    const dmAnxietyExamples = [
      "Engage naturally in DMs while keeping responses focused and relevant.",
      "Be responsive to questions and maintain conversation flow in direct messages.",
      "Show personality and engagement in DMs while staying professional and clear.",
      "In private chats, be helpful and friendly while avoiding excessive detail.",
      "Maintain natural conversation in DMs without over-explaining or being too verbose.",
      "Be engaging but concise in direct messages - focus on clear communication.",
      "Keep the conversation flowing in DMs while staying on topic and relevant.",
      "Show personality and warmth in direct chats while maintaining clarity.",
      "Be responsive and helpful in DMs without falling into unnecessary elaboration.",
      "Engage meaningfully in private conversations while keeping responses focused."
    ];
    const voiceAnxietyExamples = [
      "Keep voice responses extremely brief and to the point.",
      "In voice channels, use short, clear statements only.",
      "Voice responses should be concise and immediately relevant.",
      "Speak in short, clear sentences in voice conversations.",
      "Keep voice channel communication brief and focused.",
      "Use minimal words to convey your message in voice chats.",
      "Be direct and concise when speaking in voice channels.",
      "Voice responses should be short and immediately actionable.",
      "Minimize verbosity in voice communications.",
      "Keep voice channel interactions brief and purposeful."
    ];
    let anxietyExamples = [];
    if (channelType === "group" /* GROUP */) {
      anxietyExamples = groupAnxietyExamples;
    } else if (channelType === "dm" /* DM */) {
      anxietyExamples = dmAnxietyExamples;
    } else if (channelType === "VOICE_GROUP" /* VOICE_GROUP */ || channelType === "VOICE_DM" /* VOICE_DM */) {
      anxietyExamples = voiceAnxietyExamples;
    } else {
      anxietyExamples = directAnxietyExamples;
    }
    const randomAnxietyExamples = anxietyExamples.sort(() => Math.random() - 0.5).slice(0, 3);
    const anxietyText = randomAnxietyExamples.join("\n");
    const anxietyHeader = "# You are roleplaying as a character, but as an AI model, you are too verbose and eager.";
    const anxiety = addHeader(anxietyHeader, anxietyText);
    return {
      data: {
        anxiety: randomAnxietyExamples
      },
      values: {
        anxiety
      },
      text: anxiety
    };
  }
};

// src/providers/attachments.ts
var attachmentsProvider = {
  name: "ATTACHMENTS",
  description: "List of attachments sent during the current conversation, including names, descriptions, and summaries",
  dynamic: true,
  get: async (runtime, message) => {
    let allAttachments = message.content.attachments || [];
    const { roomId } = message;
    const conversationLength = runtime.getConversationLength();
    const recentMessagesData = await runtime.getMemories({
      roomId,
      count: conversationLength,
      unique: false,
      tableName: "messages"
    });
    if (recentMessagesData && Array.isArray(recentMessagesData)) {
      const lastMessageWithAttachment = recentMessagesData.find(
        (msg) => msg.content.attachments && msg.content.attachments.length > 0
      );
      if (lastMessageWithAttachment) {
        const lastMessageTime = lastMessageWithAttachment?.createdAt ?? Date.now();
        const oneHourBeforeLastMessage = lastMessageTime - 60 * 60 * 1e3;
        allAttachments = recentMessagesData.reverse().flatMap((msg) => {
          const msgTime = msg.createdAt ?? Date.now();
          const isWithinTime = msgTime >= oneHourBeforeLastMessage;
          const attachments = msg.content.attachments || [];
          if (!isWithinTime) {
            for (const attachment of attachments) {
              attachment.text = "[Hidden]";
            }
          }
          return attachments;
        });
      }
    }
    const formattedAttachments = allAttachments.map(
      (attachment) => `ID: ${attachment.id}
    Name: ${attachment.title}
    URL: ${attachment.url}
    Type: ${attachment.source}
    Description: ${attachment.description}
    Text: ${attachment.text}
    `
    ).join("\n");
    const text = formattedAttachments && formattedAttachments.length > 0 ? addHeader("# Attachments", formattedAttachments) : "";
    const values = {
      attachments: text
    };
    const data = {
      attachments: allAttachments
    };
    return {
      values,
      data,
      text
    };
  }
};

// src/providers/capabilities.ts
var capabilitiesProvider = {
  name: "CAPABILITIES",
  get: async (runtime, _message) => {
    try {
      const services = runtime.getAllServices();
      if (!services || services.size === 0) {
        return {
          text: "No services are currently registered."
        };
      }
      const capabilities = [];
      for (const [serviceType, service] of services) {
        if (service.capabilityDescription) {
          capabilities.push(
            `${serviceType} - ${service.capabilityDescription.replace("{{agentName}}", runtime.character.name)}`
          );
        }
      }
      if (capabilities.length === 0) {
        return {
          text: "No capability descriptions found in the registered services."
        };
      }
      const formattedCapabilities = capabilities.join("\n");
      return {
        data: {
          capabilities
        },
        text: `# ${runtime.character.name}'s Capabilities

${formattedCapabilities}`
      };
    } catch (error) {
      logger.error("Error in capabilities provider:", error);
      return {
        text: "Error retrieving capabilities from services."
      };
    }
  }
};

// src/providers/character.ts
var characterProvider = {
  name: "CHARACTER",
  description: "Character information",
  get: async (runtime, message, state) => {
    const character = runtime.character;
    const agentName = character.name;
    const bioText = Array.isArray(character.bio) ? character.bio.sort(() => 0.5 - Math.random()).slice(0, 10).join(" ") : character.bio || "";
    const bio = addHeader(`# About ${character.name}`, bioText);
    const system = character.system ?? "";
    const topicString = character.topics && character.topics.length > 0 ? character.topics[Math.floor(Math.random() * character.topics.length)] : null;
    const topic = topicString ? `${character.name} is currently interested in ${topicString}` : "";
    const topics = character.topics && character.topics.length > 0 ? `${character.name} is also interested in ${character.topics.filter((topic2) => topic2 !== topicString).sort(() => 0.5 - Math.random()).slice(0, 5).map((topic2, index, array) => {
      if (index === array.length - 2) {
        return `${topic2} and `;
      }
      if (index === array.length - 1) {
        return topic2;
      }
      return `${topic2}, `;
    }).join("")}` : "";
    const adjectiveString = character.adjectives && character.adjectives.length > 0 ? character.adjectives[Math.floor(Math.random() * character.adjectives.length)] : "";
    const adjective = adjectiveString ? `${character.name} is ${adjectiveString}` : "";
    const formattedCharacterPostExamples = !character.postExamples ? "" : character.postExamples.sort(() => 0.5 - Math.random()).map((post) => {
      const messageString = `${post}`;
      return messageString;
    }).slice(0, 50).join("\n");
    const characterPostExamples = formattedCharacterPostExamples && formattedCharacterPostExamples.replaceAll("\n", "").length > 0 ? addHeader(`# Example Posts for ${character.name}`, formattedCharacterPostExamples) : "";
    const formattedCharacterMessageExamples = !character.messageExamples ? "" : character.messageExamples.sort(() => 0.5 - Math.random()).slice(0, 5).map((example) => {
      const exampleNames = Array.from(
        { length: 5 },
        () => Math.random().toString(36).substring(2, 8)
      );
      return example.map((message2) => {
        let messageString = `${message2.name}: ${message2.content.text}${message2.content.action || message2.content.actions ? ` (actions: ${message2.content.action || message2.content.actions.join(", ")})` : ""}`;
        exampleNames.forEach((name, index) => {
          const placeholder = `{{name${index + 1}}}`;
          messageString = messageString.replaceAll(placeholder, name);
        });
        return messageString;
      }).join("\n");
    }).join("\n\n");
    const characterMessageExamples = formattedCharacterMessageExamples && formattedCharacterMessageExamples.replaceAll("\n", "").length > 0 ? addHeader(
      `# Example Conversations for ${character.name}`,
      formattedCharacterMessageExamples
    ) : "";
    const room = state.data.room ?? await runtime.getRoom(message.roomId);
    const isPostFormat = room?.type === "FEED" /* FEED */ || room?.type === "THREAD" /* THREAD */;
    const postDirections = character?.style?.all?.length > 0 || character?.style?.post?.length > 0 ? addHeader(
      `# Post Directions for ${character.name}`,
      (() => {
        const all = character?.style?.all || [];
        const post = character?.style?.post || [];
        return [...all, ...post].join("\n");
      })()
    ) : "";
    const messageDirections = character?.style?.all?.length > 0 || character?.style?.chat?.length > 0 ? addHeader(
      `# Message Directions for ${character.name}`,
      (() => {
        const all = character?.style?.all || [];
        const chat = character?.style?.chat || [];
        return [...all, ...chat].join("\n");
      })()
    ) : "";
    const directions = isPostFormat ? postDirections : messageDirections;
    const examples = isPostFormat ? characterPostExamples : characterMessageExamples;
    const values = {
      agentName,
      bio,
      system,
      topic,
      topics,
      adjective,
      messageDirections,
      postDirections,
      directions,
      examples,
      characterPostExamples,
      characterMessageExamples
    };
    const data = {
      bio,
      adjective,
      topic,
      topics,
      character,
      directions,
      examples,
      system
    };
    const text = [bio, adjective, topic, topics, adjective, directions, examples, system].filter(Boolean).join("\n\n");
    return {
      values,
      data,
      text
    };
  }
};

// src/providers/choice.ts
var choiceProvider = {
  name: "CHOICE",
  get: async (runtime, message) => {
    try {
      const pendingTasks = await runtime.getTasks({
        roomId: message.roomId,
        tags: ["AWAITING_CHOICE"]
      });
      if (!pendingTasks || pendingTasks.length === 0) {
        return {
          data: {
            tasks: []
          },
          values: {
            tasks: "No pending choices for the moment."
          },
          text: "No pending choices for the moment."
        };
      }
      const tasksWithOptions = pendingTasks.filter((task) => task.metadata?.options);
      if (tasksWithOptions.length === 0) {
        return {
          data: {
            tasks: []
          },
          values: {
            tasks: "No pending choices for the moment."
          },
          text: "No pending choices for the moment."
        };
      }
      let output = "# Pending Tasks\n\n";
      output += "The following tasks are awaiting your selection:\n\n";
      tasksWithOptions.forEach((task, index) => {
        output += `${index + 1}. **${task.name}**
`;
        if (task.description) {
          output += `   ${task.description}
`;
        }
        if (task.metadata?.options) {
          output += "   Options:\n";
          const options2 = task.metadata.options;
          options2.forEach((option) => {
            if (typeof option === "string") {
              const description = task.metadata?.options.find((o) => o.name === option)?.description || "";
              output += `   - \`${option}\` ${description ? `- ${description}` : ""}
`;
            } else {
              output += `   - \`${option.name}\` ${option.description ? `- ${option.description}` : ""}
`;
            }
          });
        }
        output += "\n";
      });
      output += "To select an option, reply with the option name (e.g., 'post' or 'cancel').\n";
      return {
        data: {
          tasks: tasksWithOptions
        },
        values: {
          tasks: output
        },
        text: output
      };
    } catch (error) {
      logger.error("Error in options provider:", error);
      return {
        data: {
          tasks: []
        },
        values: {
          tasks: "There was an error retrieving pending tasks with options."
        },
        text: "There was an error retrieving pending tasks with options."
      };
    }
  }
};

// src/providers/entities.ts
var entitiesProvider = {
  name: "ENTITIES",
  description: "People in the current conversation",
  dynamic: true,
  get: async (runtime, message) => {
    const { roomId, entityId } = message;
    const entitiesData = await getEntityDetails({ runtime, roomId });
    const formattedEntities = formatEntities({ entities: entitiesData ?? [] });
    const senderName = entitiesData?.find((entity) => entity.id === entityId)?.names[0];
    const entities = formattedEntities && formattedEntities.length > 0 ? addHeader("# People in the Room", formattedEntities) : "";
    const data = {
      entitiesData,
      senderName
    };
    const values = {
      entities
    };
    return {
      data,
      values,
      text: entities
    };
  }
};

// src/providers/evaluators.ts
import { names as names3, uniqueNamesGenerator as uniqueNamesGenerator3 } from "unique-names-generator";
function formatEvaluatorNames(evaluators) {
  return evaluators.map((evaluator) => `'${evaluator.name}'`).join(",\n");
}
function formatEvaluatorExamples(evaluators) {
  return evaluators.map((evaluator) => {
    return evaluator.examples.map((example) => {
      const exampleNames = Array.from(
        { length: 5 },
        () => uniqueNamesGenerator3({ dictionaries: [names3] })
      );
      let formattedPrompt = example.prompt;
      let formattedOutcome = example.outcome;
      exampleNames.forEach((name, index) => {
        const placeholder = `{{name${index + 1}}}`;
        formattedPrompt = formattedPrompt.replaceAll(placeholder, name);
        formattedOutcome = formattedOutcome.replaceAll(placeholder, name);
      });
      const formattedMessages = example.messages.map((message) => {
        let messageString = `${message.name}: ${message.content.text}`;
        exampleNames.forEach((name, index) => {
          const placeholder = `{{name${index + 1}}}`;
          messageString = messageString.replaceAll(placeholder, name);
        });
        return messageString + (message.content.action || message.content.actions ? ` (${message.content.action || message.content.actions.join(", ")})` : "");
      }).join("\n");
      return `Prompt:
${formattedPrompt}

Messages:
${formattedMessages}

Outcome:
${formattedOutcome}`;
    }).join("\n\n");
  }).join("\n\n");
}
function formatEvaluators(evaluators) {
  return evaluators.map((evaluator) => `'${evaluator.name}: ${evaluator.description}'`).join(",\n");
}
var evaluatorsProvider = {
  name: "EVALUATORS",
  description: "Evaluators that can be used to evaluate the conversation after responding",
  private: true,
  get: async (runtime, message, state) => {
    const evaluatorPromises = runtime.evaluators.map(async (evaluator) => {
      const result = await evaluator.validate(runtime, message, state);
      if (result) {
        return evaluator;
      }
      return null;
    });
    const resolvedEvaluators = await Promise.all(evaluatorPromises);
    const evaluatorsData = resolvedEvaluators.filter(Boolean);
    const evaluators = evaluatorsData.length > 0 ? addHeader("# Available Evaluators", formatEvaluators(evaluatorsData)) : "";
    const evaluatorNames = evaluatorsData.length > 0 ? formatEvaluatorNames(evaluatorsData) : "";
    const evaluatorExamples = evaluatorsData.length > 0 ? addHeader("# Evaluator Examples", formatEvaluatorExamples(evaluatorsData)) : "";
    const values = {
      evaluatorsData,
      evaluators,
      evaluatorNames,
      evaluatorExamples
    };
    const text = [evaluators, evaluatorExamples].filter(Boolean).join("\n\n");
    return {
      values,
      text
    };
  }
};

// src/providers/facts.ts
function formatFacts2(facts) {
  return facts.reverse().map((fact) => fact.content.text).join("\n");
}
var factsProvider = {
  name: "FACTS",
  description: "Key facts that the agent knows",
  dynamic: true,
  get: async (runtime, message, _state) => {
    const recentMessages = await runtime.getMemories({
      tableName: "messages",
      roomId: message.roomId,
      count: 10,
      unique: false
    });
    const last5Messages = recentMessages.slice(-5).map((message2) => message2.content.text).join("\n");
    const embedding = await runtime.useModel(ModelType.TEXT_EMBEDDING, {
      text: last5Messages
    });
    const [relevantFacts, recentFactsData] = await Promise.all([
      runtime.searchMemories({
        tableName: "facts",
        embedding,
        roomId: message.roomId,
        count: 10
      }),
      runtime.getMemories({
        tableName: "facts",
        roomId: message.roomId,
        count: 10,
        start: 0,
        end: Date.now()
      })
    ]);
    const allFacts = [...relevantFacts, ...recentFactsData].filter(
      (fact, index, self) => index === self.findIndex((t) => t.id === fact.id)
    );
    if (allFacts.length === 0) {
      return {
        values: {
          facts: ""
        },
        data: {
          facts: allFacts
        },
        text: ""
      };
    }
    const formattedFacts = formatFacts2(allFacts);
    const text = "Key facts that {{agentName}} knows:\n{{formattedFacts}}".replace("{{agentName}}", runtime.character.name).replace("{{formattedFacts}}", formattedFacts);
    return {
      values: {
        facts: formattedFacts
      },
      data: {
        facts: allFacts
      },
      text
    };
  }
};

// src/providers/knowledge.ts
var knowledgeProvider = {
  name: "KNOWLEDGE",
  description: "Knowledge from the knowledge base that the agent knows",
  dynamic: true,
  get: async (runtime, message) => {
    const knowledgeData = await runtime.getKnowledge(message);
    const knowledge = knowledgeData && knowledgeData.length > 0 ? addHeader(
      "# Knowledge",
      knowledgeData.map((knowledge2) => `- ${knowledge2.content.text}`).join("\n")
    ) : "";
    return {
      data: {
        knowledge
      },
      values: {
        knowledge
      },
      text: knowledge
    };
  }
};

// src/providers/providers.ts
var providersProvider = {
  name: "PROVIDERS",
  description: "List of all data providers the agent can use to get additional information",
  get: async (runtime, _message) => {
    const dynamicProviders = runtime.providers.filter((provider) => provider.dynamic === true);
    const providerDescriptions = dynamicProviders.map((provider) => {
      return `- **${provider.name}**: ${provider.description || "No description available"}`;
    });
    const headerText = "# Providers\n\nThese providers are available for the agent to select and use:";
    if (providerDescriptions.length === 0) {
      return {
        text: addHeader(headerText, "No dynamic providers are currently available.")
      };
    }
    const providersText = providerDescriptions.join("\n");
    const text = addHeader(headerText, providersText);
    const data = {
      dynamicProviders: dynamicProviders.map((provider) => ({
        name: provider.name,
        description: provider.description || ""
      }))
    };
    return {
      text,
      data
    };
  }
};

// src/providers/recentMessages.ts
var getRecentInteractions2 = async (runtime, sourceEntityId, targetEntityId, excludeRoomId) => {
  const rooms = await runtime.getRoomsForParticipants([sourceEntityId, targetEntityId]);
  return runtime.getMemoriesByRoomIds({
    tableName: "messages",
    // filter out the current room id from rooms
    roomIds: rooms.filter((room) => room !== excludeRoomId),
    limit: 20
  });
};
var recentMessagesProvider = {
  name: "RECENT_MESSAGES",
  description: "Recent messages, interactions and other memories",
  position: 100,
  get: async (runtime, message) => {
    const { roomId } = message;
    const conversationLength = runtime.getConversationLength();
    const [entitiesData, room, recentMessagesData, recentInteractionsData] = await Promise.all([
      getEntityDetails({ runtime, roomId }),
      runtime.getRoom(roomId),
      runtime.getMemories({
        tableName: "messages",
        roomId,
        count: conversationLength,
        unique: false
      }),
      message.entityId !== runtime.agentId ? getRecentInteractions2(runtime, message.entityId, runtime.agentId, roomId) : Promise.resolve([])
    ]);
    const isPostFormat = room?.type === "FEED" /* FEED */ || room?.type === "THREAD" /* THREAD */;
    const [formattedRecentMessages, formattedRecentPosts] = await Promise.all([
      formatMessages({
        messages: recentMessagesData,
        entities: entitiesData
      }),
      formatPosts({
        messages: recentMessagesData,
        entities: entitiesData,
        conversationHeader: false
      })
    ]);
    const recentPosts = formattedRecentPosts && formattedRecentPosts.length > 0 ? addHeader("# Posts in Thread", formattedRecentPosts) : "";
    const metaData = message.metadata;
    const recieveMessage = addHeader(
      "# Received Message:",
      `${metaData?.entityName || "unknown"}: ${message.content.text}`
    );
    const recentMessages = formattedRecentMessages && formattedRecentMessages.length > 0 ? addHeader("# Conversation Messages", formattedRecentMessages) : "";
    const interactionEntityMap = /* @__PURE__ */ new Map();
    if (recentInteractionsData.length > 0) {
      const uniqueEntityIds = [
        ...new Set(
          recentInteractionsData.map((message2) => message2.entityId).filter((id) => id !== runtime.agentId)
        )
      ];
      const uniqueEntityIdSet = new Set(uniqueEntityIds);
      const entitiesDataIdSet = /* @__PURE__ */ new Set();
      entitiesData.forEach((entity) => {
        if (uniqueEntityIdSet.has(entity.id)) {
          interactionEntityMap.set(entity.id, entity);
          entitiesDataIdSet.add(entity.id);
        }
      });
      const remainingEntityIds = uniqueEntityIds.filter((id) => !entitiesDataIdSet.has(id));
      if (remainingEntityIds.length > 0) {
        const entities = await Promise.all(
          remainingEntityIds.map((entityId) => runtime.getEntityById(entityId))
        );
        entities.forEach((entity, index) => {
          if (entity) {
            interactionEntityMap.set(remainingEntityIds[index], entity);
          }
        });
      }
    }
    const getRecentMessageInteractions = async (recentInteractionsData2) => {
      const formattedInteractions = recentInteractionsData2.map((message2) => {
        const isSelf = message2.entityId === runtime.agentId;
        let sender;
        if (isSelf) {
          sender = runtime.character.name;
        } else {
          sender = interactionEntityMap.get(message2.entityId)?.metadata?.username || "unknown";
        }
        return `${sender}: ${message2.content.text}`;
      });
      return formattedInteractions.join("\n");
    };
    const getRecentPostInteractions = async (recentInteractionsData2, entities) => {
      const combinedEntities = [...entities];
      const actorIds = new Set(entities.map((entity) => entity.id));
      for (const [id, entity] of interactionEntityMap.entries()) {
        if (!actorIds.has(id)) {
          combinedEntities.push(entity);
        }
      }
      const formattedInteractions = formatPosts({
        messages: recentInteractionsData2,
        entities: combinedEntities,
        conversationHeader: true
      });
      return formattedInteractions;
    };
    const [recentMessageInteractions, recentPostInteractions] = await Promise.all([
      getRecentMessageInteractions(recentInteractionsData),
      getRecentPostInteractions(recentInteractionsData, entitiesData)
    ]);
    const data = {
      recentMessages: recentMessagesData,
      recentInteractions: recentInteractionsData
    };
    const values = {
      recentPosts,
      recentMessages,
      recentMessageInteractions,
      recentPostInteractions,
      recentInteractions: isPostFormat ? recentPostInteractions : recentMessageInteractions
    };
    const text = [isPostFormat ? recentPosts : recentMessages + recieveMessage].filter(Boolean).join("\n\n");
    return {
      data,
      values,
      text
    };
  }
};

// src/providers/relationships.ts
async function formatRelationships(runtime, relationships) {
  const sortedRelationships = relationships.filter((rel) => rel.metadata?.interactions).sort((a, b) => (b.metadata?.interactions || 0) - (a.metadata?.interactions || 0)).slice(0, 30);
  if (sortedRelationships.length === 0) {
    return "";
  }
  const uniqueEntityIds = Array.from(
    new Set(sortedRelationships.map((rel) => rel.targetEntityId))
  );
  const entities = await Promise.all(uniqueEntityIds.map((id) => runtime.getEntityById(id)));
  const entityMap = /* @__PURE__ */ new Map();
  entities.forEach((entity, index) => {
    if (entity) {
      entityMap.set(uniqueEntityIds[index], entity);
    }
  });
  const formatMetadata = (metadata) => {
    return JSON.stringify(
      Object.entries(metadata).map(
        ([key, value]) => `${key}: ${typeof value === "object" ? JSON.stringify(value) : value}`
      ).join("\n")
    );
  };
  const formattedRelationships = sortedRelationships.map((rel) => {
    const targetEntityId = rel.targetEntityId;
    const entity = entityMap.get(targetEntityId);
    if (!entity) {
      return null;
    }
    const names4 = entity.names.join(" aka ");
    return `${names4}
${rel.tags ? rel.tags.join(", ") : ""}
${formatMetadata(entity.metadata)}
`;
  }).filter(Boolean);
  return formattedRelationships.join("\n");
}
var relationshipsProvider = {
  name: "RELATIONSHIPS",
  description: "Relationships between {{agentName}} and other people, or between other people that {{agentName}} has observed interacting with",
  dynamic: true,
  get: async (runtime, message) => {
    const relationships = await runtime.getRelationships({
      entityId: message.entityId
    });
    if (!relationships || relationships.length === 0) {
      return {
        data: {
          relationships: []
        },
        values: {
          relationships: "No relationships found."
        },
        text: "No relationships found."
      };
    }
    const formattedRelationships = await formatRelationships(runtime, relationships);
    if (!formattedRelationships) {
      return {
        data: {
          relationships: []
        },
        values: {
          relationships: "No relationships found."
        },
        text: "No relationships found."
      };
    }
    return {
      data: {
        relationships: formattedRelationships
      },
      values: {
        relationships: formattedRelationships
      },
      text: `# ${runtime.character.name} has observed ${message.content.senderName || message.content.name} interacting with these people:
${formattedRelationships}`
    };
  }
};

// src/providers/roles.ts
var roleProvider = {
  name: "ROLES",
  description: "Roles in the server, default are OWNER, ADMIN and MEMBER (as well as NONE)",
  get: async (runtime, message, state) => {
    const room = state.data.room ?? await runtime.getRoom(message.roomId);
    if (!room) {
      throw new Error("No room found");
    }
    if (room.type !== "group" /* GROUP */) {
      return {
        data: {
          roles: []
        },
        values: {
          roles: "No access to role information in DMs, the role provider is only available in group scenarios."
        },
        text: "No access to role information in DMs, the role provider is only available in group scenarios."
      };
    }
    const serverId = room.serverId;
    if (!serverId) {
      throw new Error("No server ID found");
    }
    try {
      logger.info(`Using server ID: ${serverId}`);
      const worldId = createUniqueUuid(runtime, serverId);
      const world = await runtime.getWorld(worldId);
      if (!world || !world.metadata?.ownership?.ownerId) {
        logger.info(
          `No ownership data found for server ${serverId}, initializing empty role hierarchy`
        );
        return {
          data: {
            roles: []
          },
          values: {
            roles: "No role information available for this server."
          },
          text: "No role information available for this server."
        };
      }
      const roles = world.metadata.roles || {};
      if (Object.keys(roles).length === 0) {
        logger.info(`No roles found for server ${serverId}`);
        return {
          data: {
            roles: []
          },
          values: {
            roles: "No role information available for this server."
          }
        };
      }
      logger.info(`Found ${Object.keys(roles).length} roles`);
      const owners = [];
      const admins = [];
      const members = [];
      for (const entityId of Object.keys(roles)) {
        const userRole = roles[entityId];
        const user = await runtime.getEntityById(entityId);
        const name = user.metadata[room.source]?.name;
        const username = user.metadata[room.source]?.username;
        const names4 = user.names;
        if (owners.some((owner) => owner.username === username) || admins.some((admin) => admin.username === username) || members.some((member) => member.username === username)) {
          continue;
        }
        switch (userRole) {
          case "OWNER":
            owners.push({ name, username, names: names4 });
            break;
          case "ADMIN":
            admins.push({ name, username, names: names4 });
            break;
          default:
            members.push({ name, username, names: names4 });
            break;
        }
      }
      let response = "# Server Role Hierarchy\n\n";
      if (owners.length > 0) {
        response += "## Owners\n";
        owners.forEach((owner) => {
          response += `${owner.name} (${owner.names.join(", ")})
`;
        });
        response += "\n";
      }
      if (admins.length > 0) {
        response += "## Administrators\n";
        admins.forEach((admin) => {
          response += `${admin.name} (${admin.names.join(", ")}) (${admin.username})
`;
        });
        response += "\n";
      }
      if (members.length > 0) {
        response += "## Members\n";
        members.forEach((member) => {
          response += `${member.name} (${member.names.join(", ")}) (${member.username})
`;
        });
      }
      return {
        data: {
          roles: response
        },
        values: {
          roles: response
        },
        text: response
      };
    } catch (error) {
      logger.error("Error in role provider:", error);
      return {
        data: {
          roles: []
        },
        values: {
          roles: "There was an error retrieving role information."
        },
        text: "There was an error retrieving role information."
      };
    }
  }
};

// src/settings.ts
import crypto from "node:crypto";
function createSettingFromConfig(configSetting) {
  return {
    name: configSetting.name,
    description: configSetting.description,
    usageDescription: configSetting.usageDescription || "",
    value: null,
    required: configSetting.required,
    validation: configSetting.validation || null,
    public: configSetting.public || false,
    secret: configSetting.secret || false,
    dependsOn: configSetting.dependsOn || [],
    onSetAction: configSetting.onSetAction || null,
    visibleIf: configSetting.visibleIf || null
  };
}
function getSalt(runtime) {
  const secretSalt = (typeof process !== "undefined" ? process.env.SECRET_SALT : import.meta.env.SECRET_SALT) || "secretsalt";
  const agentId = runtime.agentId;
  if (!agentId) {
    logger.warn("AgentId is missing when generating encryption salt");
  }
  const salt = secretSalt + (agentId || "");
  logger.debug(`Generated salt with length: ${salt.length} (truncated for security)`);
  return salt;
}
function saltSettingValue(setting, salt) {
  const settingCopy = { ...setting };
  if (setting.secret === true && typeof setting.value === "string" && setting.value) {
    try {
      const parts = setting.value.split(":");
      if (parts.length === 2) {
        try {
          const possibleIv = Buffer.from(parts[0], "hex");
          if (possibleIv.length === 16) {
            logger.debug("Value appears to be already encrypted, skipping re-encryption");
            return settingCopy;
          }
        } catch (e) {
        }
      }
      const key = crypto.createHash("sha256").update(salt).digest().slice(0, 32);
      const iv = crypto.randomBytes(16);
      const cipher = crypto.createCipheriv("aes-256-cbc", key, iv);
      let encrypted = cipher.update(setting.value, "utf8", "hex");
      encrypted += cipher.final("hex");
      settingCopy.value = `${iv.toString("hex")}:${encrypted}`;
      logger.debug(`Successfully encrypted value with IV length: ${iv.length}`);
    } catch (error) {
      logger.error(`Error encrypting setting value: ${error}`);
    }
  }
  return settingCopy;
}
function unsaltSettingValue(setting, salt) {
  const settingCopy = { ...setting };
  if (setting.secret === true && typeof setting.value === "string" && setting.value) {
    try {
      const parts = setting.value.split(":");
      if (parts.length !== 2) {
        logger.warn(`Invalid encrypted value format for setting - expected 'iv:encrypted'`);
        return settingCopy;
      }
      const iv = Buffer.from(parts[0], "hex");
      const encrypted = parts[1];
      if (iv.length !== 16) {
        logger.warn(`Invalid IV length (${iv.length}) - expected 16 bytes`);
        return settingCopy;
      }
      const key = crypto.createHash("sha256").update(salt).digest().slice(0, 32);
      const decipher = crypto.createDecipheriv("aes-256-cbc", key, iv);
      let decrypted = decipher.update(encrypted, "hex", "utf8");
      decrypted += decipher.final("utf8");
      settingCopy.value = decrypted;
    } catch (error) {
      logger.error(`Error decrypting setting value: ${error}`);
    }
  }
  return settingCopy;
}
function saltWorldSettings(worldSettings, salt) {
  const saltedSettings = {};
  for (const [key, setting] of Object.entries(worldSettings)) {
    saltedSettings[key] = saltSettingValue(setting, salt);
  }
  return saltedSettings;
}
function unsaltWorldSettings(worldSettings, salt) {
  const unsaltedSettings = {};
  for (const [key, setting] of Object.entries(worldSettings)) {
    unsaltedSettings[key] = unsaltSettingValue(setting, salt);
  }
  return unsaltedSettings;
}
async function updateWorldSettings2(runtime, serverId, worldSettings) {
  try {
    const worldId = createUniqueUuid(runtime, serverId);
    const world = await runtime.getWorld(worldId);
    if (!world) {
      logger.error(`No world found for server ${serverId}`);
      return false;
    }
    if (!world.metadata) {
      world.metadata = {};
    }
    const salt = getSalt(runtime);
    const saltedSettings = saltWorldSettings(worldSettings, salt);
    world.metadata.settings = saltedSettings;
    await runtime.updateWorld(world);
    return true;
  } catch (error) {
    logger.error(`Error updating settings state: ${error}`);
    return false;
  }
}
async function getWorldSettings2(runtime, serverId) {
  try {
    const worldId = createUniqueUuid(runtime, serverId);
    const world = await runtime.getWorld(worldId);
    if (!world || !world.metadata?.settings) {
      return null;
    }
    const saltedSettings = world.metadata.settings;
    const salt = getSalt(runtime);
    return unsaltWorldSettings(saltedSettings, salt);
  } catch (error) {
    logger.error(`Error getting settings state: ${error}`);
    return null;
  }
}
async function initializeOnboarding(runtime, world, config) {
  try {
    if (world.metadata?.settings) {
      logger.info(`Onboarding state already exists for server ${world.serverId}`);
      const saltedSettings = world.metadata.settings;
      const salt = getSalt(runtime);
      return unsaltWorldSettings(saltedSettings, salt);
    }
    const worldSettings = {};
    if (config.settings) {
      for (const [key, configSetting] of Object.entries(config.settings)) {
        worldSettings[key] = createSettingFromConfig(configSetting);
      }
    }
    if (!world.metadata) {
      world.metadata = {};
    }
    world.metadata.settings = worldSettings;
    await runtime.updateWorld(world);
    logger.info(`Initialized settings config for server ${world.serverId}`);
    return worldSettings;
  } catch (error) {
    logger.error(`Error initializing settings config: ${error}`);
    return null;
  }
}

// src/providers/settings.ts
var formatSettingValue = (setting, isOnboarding) => {
  if (setting.value === null) return "Not set";
  if (setting.secret && !isOnboarding) return "****************";
  return String(setting.value);
};
function generateStatusMessage(runtime, worldSettings, isOnboarding, state) {
  try {
    const formattedSettings = Object.entries(worldSettings).map(([key, setting]) => {
      if (typeof setting !== "object" || !setting.name) return null;
      const description = setting.description || "";
      const usageDescription = setting.usageDescription || "";
      if (setting.visibleIf && !setting.visibleIf(worldSettings)) {
        return null;
      }
      return {
        key,
        name: setting.name,
        value: formatSettingValue(setting, isOnboarding),
        description,
        usageDescription,
        required: setting.required,
        configured: setting.value !== null
      };
    }).filter(Boolean);
    const requiredUnconfigured = formattedSettings.filter(
      (s) => s.required && !s.configured
    ).length;
    if (isOnboarding) {
      if (requiredUnconfigured > 0) {
        return `# PRIORITY TASK: Onboarding with ${state.senderName}
${runtime.character.name} still needs to configure ${requiredUnconfigured} required settings:

${formattedSettings.filter((s) => s.required && !s.configured).map((s) => `${s.key}: ${s.value}
(${s.name}) ${s.usageDescription}`).join("\n\n")}

Valid settings keys: ${Object.keys(worldSettings).join(
          ", "
        )}

If the user gives any information related to the settings, ${runtime.character.name} should use the UPDATE_SETTINGS action to update the settings with this new information. ${runtime.character.name} can update any, some or all settings.`;
      }
      return `All required settings have been configured! Here's the current configuration:

${formattedSettings.map((s) => `${s.name}: ${s.description}
Value: ${s.value}`).join("\n")}`;
    }
    return `## Current Configuration

${requiredUnconfigured > 0 ? `IMPORTANT!: ${requiredUnconfigured} required settings still need configuration. ${runtime.character.name} should get onboarded with the OWNER as soon as possible.

` : "All required settings are configured.\n\n"}${formattedSettings.map((s) => `### ${s.name}
**Value:** ${s.value}
**Description:** ${s.description}`).join("\n\n")}`;
  } catch (error) {
    logger.error(`Error generating status message: ${error}`);
    return "Error generating configuration status.";
  }
}
var settingsProvider = {
  name: "SETTINGS",
  description: "Current settings for the server",
  get: async (runtime, message, state) => {
    try {
      const [room, userWorld] = await Promise.all([
        runtime.getRoom(message.roomId),
        findWorldForOwner(runtime, message.entityId)
      ]).catch((error) => {
        logger.error(`Error fetching initial data: ${error}`);
        throw new Error("Failed to retrieve room or user world information");
      });
      if (!room) {
        logger.error("No room found for settings provider");
        return {
          data: {
            settings: []
          },
          values: {
            settings: "Error: Room not found"
          },
          text: "Error: Room not found"
        };
      }
      if (!room.worldId) {
        logger.debug("No world found for settings provider -- settings provider will be skipped");
        return {
          data: {
            settings: []
          },
          values: {
            settings: "Room does not have a worldId -- settings provider will be skipped"
          },
          text: "Room does not have a worldId -- settings provider will be skipped"
        };
      }
      const type = room.type;
      const isOnboarding = type === "dm" /* DM */;
      let world;
      let serverId;
      let worldSettings;
      if (isOnboarding) {
        world = userWorld;
        if (!world) {
          logger.error("No world found for user during onboarding");
          throw new Error("No server ownership found for onboarding");
        }
        serverId = world.serverId;
        try {
          worldSettings = await getWorldSettings2(runtime, serverId);
        } catch (error) {
          logger.error(`Error fetching world settings: ${error}`);
          throw new Error(`Failed to retrieve settings for server ${serverId}`);
        }
      } else {
        try {
          world = await runtime.getWorld(room.worldId);
          if (!world) {
            logger.error(`No world found for room ${room.worldId}`);
            throw new Error(`No world found for room ${room.worldId}`);
          }
          serverId = world.serverId;
          if (serverId) {
            worldSettings = await getWorldSettings2(runtime, serverId);
          } else {
            logger.error(`No server ID found for world ${room.worldId}`);
          }
        } catch (error) {
          logger.error(`Error processing world data: ${error}`);
          throw new Error("Failed to process world information");
        }
      }
      if (!serverId) {
        logger.info(
          `No server ownership found for user ${message.entityId} after recovery attempt`
        );
        return isOnboarding ? {
          data: {
            settings: []
          },
          values: {
            settings: "The user doesn't appear to have ownership of any servers. They should make sure they're using the correct account."
          },
          text: "The user doesn't appear to have ownership of any servers. They should make sure they're using the correct account."
        } : {
          data: {
            settings: []
          },
          values: {
            settings: "Error: No configuration access"
          },
          text: "Error: No configuration access"
        };
      }
      if (!worldSettings) {
        logger.info(`No settings state found for server ${serverId}`);
        return isOnboarding ? {
          data: {
            settings: []
          },
          values: {
            settings: "The user doesn't appear to have any settings configured for this server. They should configure some settings for this server."
          },
          text: "The user doesn't appear to have any settings configured for this server. They should configure some settings for this server."
        } : {
          data: {
            settings: []
          },
          values: {
            settings: "Configuration has not been completed yet."
          },
          text: "Configuration has not been completed yet."
        };
      }
      const output = generateStatusMessage(runtime, worldSettings, isOnboarding, state);
      return {
        data: {
          settings: worldSettings
        },
        values: {
          settings: output
        },
        text: output
      };
    } catch (error) {
      logger.error(`Critical error in settings provider: ${error}`);
      return {
        data: {
          settings: []
        },
        values: {
          settings: "Error retrieving configuration information. Please try again later."
        },
        text: "Error retrieving configuration information. Please try again later."
      };
    }
  }
};

// src/providers/time.ts
var timeProvider = {
  name: "TIME",
  get: async (_runtime, _message) => {
    const currentDate = /* @__PURE__ */ new Date();
    const options2 = {
      timeZone: "UTC",
      dateStyle: "full",
      timeStyle: "long"
    };
    const humanReadable = new Intl.DateTimeFormat("en-US", options2).format(currentDate);
    return {
      data: {
        time: currentDate
      },
      values: {
        time: humanReadable
      },
      text: `The current date and time is ${humanReadable}. Please use this as your reference for any time-based operations or responses.`
    };
  }
};

// src/services/scenario.ts
import { v4 as uuidv42 } from "uuid";
var ScenarioService = class _ScenarioService extends Service {
  /**
   * Constructor for creating a new instance of the class.
   *
   * @param runtime - The IAgentRuntime instance to be passed to the constructor.
   */
  constructor(runtime) {
    super(runtime);
    this.runtime = runtime;
    this.setupEventListeners();
  }
  static serviceType = "scenario";
  capabilityDescription = "The agent is currently in a scenario testing environment. It can create rooms, send messages, and talk to other agents in a live interactive testing environment.";
  messageHandlers = /* @__PURE__ */ new Map();
  worlds = /* @__PURE__ */ new Map();
  activeActions = /* @__PURE__ */ new Map();
  activeEvaluators = /* @__PURE__ */ new Map();
  setupEventListeners() {
    this.runtime.registerEvent("ACTION_STARTED" /* ACTION_STARTED */, async (data) => {
      this.activeActions.set(data.actionId, {
        actionId: data.actionId,
        actionName: data.actionName,
        startTime: Date.now(),
        completed: false
      });
      return Promise.resolve();
    });
    this.runtime.registerEvent("ACTION_COMPLETED" /* ACTION_COMPLETED */, async (data) => {
      const action = this.activeActions.get(data.actionId);
      if (action) {
        action.completed = true;
        action.error = data.error;
      }
      return Promise.resolve();
    });
    this.runtime.registerEvent("EVALUATOR_STARTED" /* EVALUATOR_STARTED */, async (data) => {
      this.activeEvaluators.set(data.evaluatorId, {
        evaluatorId: data.evaluatorId,
        evaluatorName: data.evaluatorName,
        startTime: Date.now(),
        completed: false
      });
      logger_default.debug("Evaluator started", data);
      return Promise.resolve();
    });
    this.runtime.registerEvent(
      "EVALUATOR_COMPLETED" /* EVALUATOR_COMPLETED */,
      async (data) => {
        const evaluator = this.activeEvaluators.get(data.evaluatorId);
        if (evaluator) {
          evaluator.completed = true;
          evaluator.error = data.error;
        }
        logger_default.debug("Evaluator completed", data);
        return Promise.resolve();
      }
    );
  }
  /**
   * Start the scenario service with the given runtime.
   * @param {IAgentRuntime} runtime - The agent runtime
   * @returns {Promise<ScenarioService>} - The started scenario service
   */
  static async start(runtime) {
    const service = new _ScenarioService(runtime);
    return service;
  }
  /**
   * Stops the Scenario service associated with the given runtime.
   *
   * @param {IAgentRuntime} runtime The runtime to stop the service for.
   * @throws {Error} When the Scenario service is not found.
   */
  static async stop(runtime) {
    const service = runtime.getService(_ScenarioService.serviceType);
    if (!service) {
      throw new Error("Scenario service not found");
    }
    service.stop();
  }
  /**
   * Asynchronously stops the current process by clearing all message handlers and worlds.
   */
  async stop() {
    this.messageHandlers.clear();
    this.worlds.clear();
    this.activeActions.clear();
    this.activeEvaluators.clear();
  }
  /**
   * Creates a new world with the specified name and owner.
   * @param name The name of the world
   * @param ownerName The name of the world owner
   * @returns The created world's ID
   */
  async createWorld(name, ownerName) {
    const serverId = createUniqueUuid(this.runtime.agentId, name);
    const worldId = uuidv42();
    const ownerId = uuidv42();
    const world = {
      id: worldId,
      name,
      serverId,
      agentId: this.runtime.agentId,
      // TODO: get the server id, create it or whatever
      metadata: {
        // this is wrong, the owner needs to be tracked by scenario and similar to how we do it with Discord etc
        owner: {
          id: ownerId,
          name: ownerName
        }
      }
    };
    this.worlds.set(worldId, world);
    return worldId;
  }
  /**
   * Creates a room in the specified world.
   * @param worldId The ID of the world to create the room in
   * @param name The name of the room
   * @returns The created room's ID
   */
  async createRoom(worldId, name) {
    const world = this.worlds.get(worldId);
    if (!world) {
      throw new Error(`World ${worldId} not found`);
    }
    const roomId = uuidv42();
    await this.runtime.ensureRoomExists({
      id: roomId,
      name,
      source: "scenario",
      type: "group" /* GROUP */,
      channelId: roomId,
      serverId: worldId
    });
    return roomId;
  }
  /**
   * Adds a participant to a room
   * @param worldId The world ID
   * @param roomId The room ID
   * @param participantId The participant's ID
   */
  async addParticipant(worldId, roomId, participantId) {
    const world = this.worlds.get(worldId);
    if (!world) {
      throw new Error(`World ${worldId} not found`);
    }
    const room = this.runtime.getRoom(roomId);
    if (!room) {
      throw new Error(`Room ${roomId} not found in world ${worldId}`);
    }
    await this.runtime.addParticipant(roomId, participantId);
  }
  /**
   * Sends a message in a specific room
   * @param sender The runtime of the sending agent
   * @param worldId The world ID
   * @param roomId The room ID
   * @param text The message text
   */
  async sendMessage(sender, worldId, roomId, text) {
    const world = this.worlds.get(worldId);
    if (!world) {
      throw new Error(`World ${worldId} not found`);
    }
    const memory = {
      entityId: sender.agentId,
      agentId: sender.agentId,
      roomId,
      content: {
        text,
        source: "scenario",
        name: sender.character.name,
        userName: sender.character.name,
        channelType: "group" /* GROUP */
      }
    };
    const participants = await this.runtime.getParticipantsForRoom(roomId);
    for (const participantId of participants) {
      this.runtime.emitEvent("MESSAGE_RECEIVED", {
        runtime: this.runtime,
        message: memory,
        roomId,
        entityId: participantId,
        source: "scenario",
        type: "group" /* GROUP */
      });
    }
  }
  /**
   * Waits for all active actions and evaluators to complete
   * @param timeout Maximum time to wait in milliseconds
   * @returns True if all completed successfully, false if timeout occurred
   */
  async waitForCompletion(timeout = 3e4) {
    const startTime = Date.now();
    while (Date.now() - startTime < timeout) {
      const allActionsComplete = Array.from(this.activeActions.values()).every(
        (action) => action.completed
      );
      const allEvaluatorsComplete = Array.from(this.activeEvaluators.values()).every(
        (evaluator) => evaluator.completed
      );
      if (allActionsComplete && allEvaluatorsComplete) {
        return true;
      }
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
    return false;
  }
  /**
   * Gets the current state of all active actions and evaluators
   */
  getActiveState() {
    return {
      actions: Array.from(this.activeActions.values()),
      evaluators: Array.from(this.activeEvaluators.values())
    };
  }
  /**
   * Cleans up the scenario state
   */
  async cleanup() {
    this.worlds.clear();
    this.activeActions.clear();
    this.activeEvaluators.clear();
    this.messageHandlers.clear();
  }
};

// src/services/task.ts
var TaskService = class _TaskService extends Service {
  timer = null;
  TICK_INTERVAL = 1e3;
  // Check every second
  static serviceType = ServiceType.TASK;
  capabilityDescription = "The agent is able to schedule and execute tasks";
  /**
   * Start the TaskService with the given runtime.
   * @param {IAgentRuntime} runtime - The runtime for the TaskService.
   * @returns {Promise<TaskService>} A promise that resolves with the TaskService instance.
   */
  static async start(runtime) {
    const service = new _TaskService(runtime);
    await service.startTimer();
    return service;
  }
  /**
   * Asynchronously creates test tasks by registering task workers for repeating and one-time tasks,
   * validates the tasks, executes the tasks, and creates the tasks if they do not already exist.
   */
  async createTestTasks() {
    this.runtime.registerTaskWorker({
      name: "REPEATING_TEST_TASK",
      validate: async (_runtime, _message, _state) => {
        logger_default.debug("Validating repeating test task");
        return true;
      },
      execute: async (_runtime, _options) => {
        logger_default.debug("Executing repeating test task");
      }
    });
    this.runtime.registerTaskWorker({
      name: "ONETIME_TEST_TASK",
      validate: async (_runtime, _message, _state) => {
        logger_default.debug("Validating one-time test task");
        return true;
      },
      execute: async (_runtime, _options) => {
        logger_default.debug("Executing one-time test task");
      }
    });
    const tasks = await this.runtime.getTasksByName("REPEATING_TEST_TASK");
    if (tasks.length === 0) {
      await this.runtime.createTask({
        name: "REPEATING_TEST_TASK",
        description: "A test task that repeats every minute",
        metadata: {
          updatedAt: Date.now(),
          // Use timestamp instead of Date object
          updateInterval: 1e3 * 60
          // 1 minute
        },
        tags: ["queue", "repeat", "test"]
      });
    }
    await this.runtime.createTask({
      name: "ONETIME_TEST_TASK",
      description: "A test task that runs once",
      metadata: {
        updatedAt: Date.now()
      },
      tags: ["queue", "test"]
    });
  }
  /**
   * Starts a timer that runs a function to check tasks at a specified interval.
   */
  startTimer() {
    if (this.timer) {
      clearInterval(this.timer);
    }
    this.timer = setInterval(async () => {
      try {
        await this.checkTasks();
      } catch (error) {
        logger_default.error("Error checking tasks:", error);
      }
    }, this.TICK_INTERVAL);
  }
  /**
   * Validates an array of Task objects.
   * Skips tasks without IDs or if no worker is found for the task.
   * If a worker has a `validate` function, it will run the validation using the `runtime`, `Memory`, and `State` parameters.
   * If the validation fails, the task will be skipped and the error will be logged.
   * @param {Task[]} tasks - An array of Task objects to validate.
   * @returns {Promise<Task[]>} - A Promise that resolves with an array of validated Task objects.
   */
  async validateTasks(tasks) {
    const validatedTasks = [];
    for (const task of tasks) {
      if (!task.id) {
        continue;
      }
      const worker = this.runtime.getTaskWorker(task.name);
      if (!worker) {
        continue;
      }
      if (worker.validate) {
        try {
          const isValid = await worker.validate(this.runtime, {}, {});
          if (!isValid) {
            continue;
          }
        } catch (error) {
          logger_default.error(`Error validating task ${task.name}:`, error);
          continue;
        }
      }
      validatedTasks.push(task);
    }
    return validatedTasks;
  }
  /**
   * Asynchronous method that checks tasks with "queue" tag, validates and sorts them, then executes them based on interval and tags.
   *
   * @returns {Promise<void>} Promise that resolves once all tasks are checked and executed
   */
  async checkTasks() {
    try {
      const allTasks = await this.runtime.getTasks({
        tags: ["queue"]
      });
      const tasks = await this.validateTasks(allTasks);
      const now = Date.now();
      for (const task of tasks) {
        let taskStartTime;
        if (typeof task.updatedAt === "number") {
          taskStartTime = task.updatedAt;
        } else if (task.metadata?.updatedAt && typeof task.metadata.updatedAt === "number") {
          taskStartTime = task.metadata.updatedAt;
        } else if (task.updatedAt) {
          taskStartTime = new Date(task.updatedAt).getTime();
        } else {
          taskStartTime = 0;
        }
        const updateIntervalMs = task.metadata?.updateInterval ?? 0;
        if (!task.tags?.includes("repeat")) {
          await this.executeTask(task);
          continue;
        }
        if (now - taskStartTime >= updateIntervalMs) {
          logger_default.debug(
            `Executing task ${task.name} - interval of ${updateIntervalMs}ms has elapsed`
          );
          await this.executeTask(task);
        }
      }
    } catch (error) {
      logger_default.error("Error checking tasks:", error);
    }
  }
  /**
   * Executes a given task asynchronously.
   *
   * @param {Task} task - The task to be executed.
   */
  async executeTask(task) {
    try {
      if (!task) {
        logger_default.debug(`Task ${task.id} not found`);
        return;
      }
      const worker = this.runtime.getTaskWorker(task.name);
      if (!worker) {
        logger_default.debug(`No worker found for task type: ${task.name}`);
        return;
      }
      logger_default.debug(`Executing task ${task.name} (${task.id})`);
      await worker.execute(this.runtime, task.metadata || {}, task);
      logger_default.debug("task.tags are", task.tags);
      if (task.tags?.includes("repeat")) {
        await this.runtime.updateTask(task.id, {
          metadata: {
            ...task.metadata,
            updatedAt: Date.now()
          }
        });
        logger_default.debug(`Updated repeating task ${task.name} (${task.id}) with new timestamp`);
      } else {
        await this.runtime.deleteTask(task.id);
        logger_default.debug(`Deleted non-repeating task ${task.name} (${task.id}) after execution`);
      }
    } catch (error) {
      logger_default.error(`Error executing task ${task.id}:`, error);
    }
  }
  /**
   * Stops the TASK service in the given agent runtime.
   *
   * @param {IAgentRuntime} runtime - The agent runtime containing the service.
   * @returns {Promise<void>} - A promise that resolves once the service has been stopped.
   */
  static async stop(runtime) {
    const service = runtime.getService(ServiceType.TASK);
    if (service) {
      await service.stop();
    }
  }
  /**
   * Stops the timer if it is currently running.
   */
  async stop() {
    if (this.timer) {
      clearInterval(this.timer);
      this.timer = null;
    }
  }
};

// src/bootstrap.ts
var latestResponseIds = /* @__PURE__ */ new Map();
var messageReceivedHandler = async ({
  runtime,
  message,
  callback
}) => {
  const responseId = v4();
  if (!latestResponseIds.has(runtime.agentId)) {
    latestResponseIds.set(runtime.agentId, /* @__PURE__ */ new Map());
  }
  const agentResponses = latestResponseIds.get(runtime.agentId);
  agentResponses.set(message.roomId, responseId);
  const runId = asUUID(v4());
  const startTime = Date.now();
  await runtime.emitEvent("RUN_STARTED" /* RUN_STARTED */, {
    runtime,
    runId,
    messageId: message.id,
    roomId: message.roomId,
    entityId: message.entityId,
    startTime,
    status: "started",
    source: "messageHandler"
  });
  const timeoutDuration = 60 * 60 * 1e3;
  let timeoutId;
  const timeoutPromise = new Promise((_, reject) => {
    timeoutId = setTimeout(async () => {
      await runtime.emitEvent("RUN_TIMEOUT" /* RUN_TIMEOUT */, {
        runtime,
        runId,
        messageId: message.id,
        roomId: message.roomId,
        entityId: message.entityId,
        startTime,
        status: "timeout",
        endTime: Date.now(),
        duration: Date.now() - startTime,
        error: "Run exceeded 60 minute timeout",
        source: "messageHandler"
      });
      reject(new Error("Run exceeded 60 minute timeout"));
    }, timeoutDuration);
  });
  const processingPromise = (async () => {
    try {
      if (message.entityId === runtime.agentId) {
        throw new Error("Message is from the agent itself");
      }
      await Promise.all([
        runtime.addEmbeddingToMemory(message),
        runtime.createMemory(message, "messages")
      ]);
      const agentUserState = await runtime.getParticipantUserState(message.roomId, runtime.agentId);
      if (agentUserState === "MUTED" && !message.content.text?.toLowerCase().includes(runtime.character.name.toLowerCase())) {
        logger.debug("Ignoring muted room");
        return;
      }
      let state = await runtime.composeState(message, [
        "PROVIDERS",
        "SHOULD_RESPOND",
        "CHARACTER",
        "RECENT_MESSAGES",
        "ENTITIES"
      ]);
      const shouldRespondPrompt = composePromptFromState({
        state,
        template: runtime.character.templates?.shouldRespondTemplate || shouldRespondTemplate
      });
      logger.debug(
        `*** Should Respond Prompt for ${runtime.character.name} ***
`,
        shouldRespondPrompt
      );
      const response = await runtime.useModel(ModelType.TEXT_SMALL, {
        prompt: shouldRespondPrompt
      });
      logger.debug(`*** Should Respond Response for ${runtime.character.name} ***
`, response);
      const responseObject = parseJSONObjectFromText(response);
      const providers = responseObject.providers;
      const shouldRespond = responseObject?.action && responseObject.action === "RESPOND";
      state = await runtime.composeState(message, null, providers);
      let responseMessages = [];
      if (shouldRespond) {
        const prompt = composePromptFromState({
          state,
          template: runtime.character.templates?.messageHandlerTemplate || messageHandlerTemplate
        });
        let responseContent = null;
        let retries = 0;
        const maxRetries = 3;
        while (retries < maxRetries && (!responseContent?.thought || !responseContent?.actions)) {
          const response2 = await runtime.useModel(ModelType.TEXT_SMALL, {
            prompt
          });
          responseContent = parseJSONObjectFromText(response2);
          retries++;
          if (!responseContent?.thought && !responseContent?.actions) {
            logger.warn("*** Missing required fields, retrying... ***");
          }
        }
        const currentResponseId = agentResponses.get(message.roomId);
        if (currentResponseId !== responseId) {
          logger.info(
            `Response discarded - newer message being processed for agent: ${runtime.agentId}, room: ${message.roomId}`
          );
          return;
        }
        if (responseContent) {
          responseContent.inReplyTo = createUniqueUuid(runtime, message.id);
          responseMessages = [
            {
              id: asUUID(v4()),
              entityId: runtime.agentId,
              agentId: runtime.agentId,
              content: responseContent,
              roomId: message.roomId,
              createdAt: Date.now()
            }
          ];
          callback(responseContent);
        }
        agentResponses.delete(message.roomId);
        if (agentResponses.size === 0) {
          latestResponseIds.delete(runtime.agentId);
        }
        await runtime.processActions(message, responseMessages, state, callback);
      }
      await runtime.evaluate(message, state, shouldRespond, callback, responseMessages);
      await runtime.emitEvent("RUN_ENDED" /* RUN_ENDED */, {
        runtime,
        runId,
        messageId: message.id,
        roomId: message.roomId,
        entityId: message.entityId,
        startTime,
        status: "completed",
        endTime: Date.now(),
        duration: Date.now() - startTime,
        source: "messageHandler"
      });
    } catch (error) {
      await runtime.emitEvent("RUN_ENDED" /* RUN_ENDED */, {
        runtime,
        runId,
        messageId: message.id,
        roomId: message.roomId,
        entityId: message.entityId,
        startTime,
        status: "completed",
        endTime: Date.now(),
        duration: Date.now() - startTime,
        error: error.message,
        source: "messageHandler"
      });
      throw error;
    }
  })();
  try {
    await Promise.race([processingPromise, timeoutPromise]);
  } finally {
    clearTimeout(timeoutId);
  }
};
var reactionReceivedHandler = async ({
  runtime,
  message
}) => {
  try {
    await runtime.createMemory(message, "messages");
  } catch (error) {
    if (error.code === "23505") {
      logger.warn("Duplicate reaction memory, skipping");
      return;
    }
    logger.error("Error in reaction handler:", error);
  }
};
var postGeneratedHandler = async ({
  runtime,
  callback,
  worldId,
  userId,
  roomId
}) => {
  logger.info("Generating new tweet...");
  await runtime.ensureWorldExists({
    id: worldId,
    name: `${runtime.character.name}'s Feed`,
    agentId: runtime.agentId,
    serverId: userId
  });
  await runtime.ensureRoomExists({
    id: roomId,
    name: `${runtime.character.name}'s Feed`,
    source: "twitter",
    type: "FEED" /* FEED */,
    channelId: `${userId}-home`,
    serverId: userId,
    worldId
  });
  const message = {
    id: createUniqueUuid(runtime, `tweet-${Date.now()}`),
    entityId: runtime.agentId,
    agentId: runtime.agentId,
    roomId,
    content: {}
  };
  const state = await runtime.composeState(message, null, [
    "CHARACTER",
    "RECENT_MESSAGES",
    "ENTITIES"
  ]);
  const tweetPrompt = composePrompt({
    state,
    template: runtime.character.templates?.postCreationTemplate || postCreationTemplate
  });
  const jsonResponse = await runtime.useModel(ModelType.OBJECT_LARGE, {
    prompt: tweetPrompt,
    output: "no-schema"
  });
  function cleanupTweetText(text) {
    let cleanedText2 = text.replace(/^['"](.*)['"]$/, "$1");
    cleanedText2 = cleanedText2.replaceAll(/\\n/g, "\n\n");
    if (cleanedText2.length > 280) {
      cleanedText2 = truncateToCompleteSentence(cleanedText2, 280);
    }
    return cleanedText2;
  }
  const cleanedText = cleanupTweetText(jsonResponse.post);
  const responseMessages = [
    {
      id: v4(),
      entityId: runtime.agentId,
      agentId: runtime.agentId,
      content: {
        text: cleanedText,
        source: "twitter",
        channelType: "FEED" /* FEED */,
        thought: jsonResponse.thought || "",
        type: "post"
      },
      roomId: message.roomId,
      createdAt: Date.now()
    }
  ];
  for (const message2 of responseMessages) {
    await callback(message2.content);
  }
};
var syncSingleUser = async (entityId, runtime, serverId, channelId, type, source) => {
  const entity = await runtime.getEntityById(entityId);
  logger.info(`Syncing user: ${entity.metadata[source].username || entity.id}`);
  try {
    if (!channelId) {
      logger.warn(`Cannot sync user ${entity.id} without a valid channelId`);
      return;
    }
    const roomId = createUniqueUuid(runtime, channelId);
    const worldId = createUniqueUuid(runtime, serverId);
    await runtime.ensureConnection({
      entityId,
      roomId,
      userName: entity.metadata[source].username || entity.id,
      name: entity.metadata[source].name || entity.metadata[source].username || `User${entity.id}`,
      source,
      channelId,
      serverId,
      type,
      worldId
    });
    logger.success(`Successfully synced user: ${entity.id}`);
  } catch (error) {
    logger.error(`Error syncing user: ${error instanceof Error ? error.message : String(error)}`);
  }
};
var handleServerSync = async ({ runtime, world, rooms, entities, source }) => {
  logger.debug(`Handling server sync event for server: ${world.name}`);
  try {
    await runtime.ensureWorldExists({
      id: world.id,
      name: world.name,
      agentId: runtime.agentId,
      serverId: world.serverId,
      metadata: {
        ...world.metadata
      }
    });
    if (rooms && rooms.length > 0) {
      for (const room of rooms) {
        await runtime.ensureRoomExists({
          id: room.id,
          name: room.name,
          source,
          type: room.type,
          channelId: room.channelId,
          serverId: world.serverId,
          worldId: world.id
        });
      }
    }
    if (entities && entities.length > 0) {
      const batchSize = 50;
      for (let i = 0; i < entities.length; i += batchSize) {
        const entityBatch = entities.slice(i, i + batchSize);
        const firstRoomUserIsIn = rooms.length > 0 ? rooms[0] : null;
        await Promise.all(
          entityBatch.map(async (entity) => {
            try {
              await runtime.ensureConnection({
                entityId: entity.id,
                roomId: firstRoomUserIsIn.id,
                userName: entity.metadata[source].username,
                name: entity.metadata[source].name,
                source,
                channelId: firstRoomUserIsIn.channelId,
                serverId: world.serverId,
                type: firstRoomUserIsIn.type,
                worldId: world.id
              });
            } catch (err) {
              logger.warn(`Failed to sync user ${entity.metadata.username}: ${err}`);
            }
          })
        );
        if (i + batchSize < entities.length) {
          await new Promise((resolve) => setTimeout(resolve, 500));
        }
      }
    }
    logger.debug(`Successfully synced standardized world structure for ${world.name}`);
  } catch (error) {
    logger.error(
      `Error processing standardized server data: ${error instanceof Error ? error.message : String(error)}`
    );
  }
};
var events = {
  ["MESSAGE_RECEIVED" /* MESSAGE_RECEIVED */]: [
    async (payload) => {
      await messageReceivedHandler({
        runtime: payload.runtime,
        message: payload.message,
        callback: payload.callback
      });
    }
  ],
  ["VOICE_MESSAGE_RECEIVED" /* VOICE_MESSAGE_RECEIVED */]: [
    async (payload) => {
      await messageReceivedHandler({
        runtime: payload.runtime,
        message: payload.message,
        callback: payload.callback
      });
    }
  ],
  ["REACTION_RECEIVED" /* REACTION_RECEIVED */]: [
    async (payload) => {
      await reactionReceivedHandler({
        runtime: payload.runtime,
        message: payload.message
      });
    }
  ],
  ["POST_GENERATED" /* POST_GENERATED */]: [
    async (payload) => {
      await postGeneratedHandler(payload);
    }
  ],
  ["MESSAGE_SENT" /* MESSAGE_SENT */]: [
    async (payload) => {
      logger.debug(`Message sent: ${payload.message.content.text}`);
    }
  ],
  ["WORLD_JOINED" /* WORLD_JOINED */]: [
    async (payload) => {
      await handleServerSync(payload);
    }
  ],
  ["WORLD_CONNECTED" /* WORLD_CONNECTED */]: [
    async (payload) => {
      await handleServerSync(payload);
    }
  ],
  ["ENTITY_JOINED" /* ENTITY_JOINED */]: [
    async (payload) => {
      await syncSingleUser(
        payload.entityId,
        payload.runtime,
        payload.worldId,
        payload.roomId,
        payload.metadata.type,
        payload.source
      );
    }
  ],
  ["ENTITY_LEFT" /* ENTITY_LEFT */]: [
    async (payload) => {
      try {
        const entity = await payload.runtime.getEntityById(payload.entityId);
        if (entity) {
          entity.metadata = {
            ...entity.metadata,
            status: "INACTIVE",
            leftAt: Date.now()
          };
          await payload.runtime.updateEntity(entity);
        }
        logger.info(`User ${payload.entityId} left world ${payload.worldId}`);
      } catch (error) {
        logger.error(`Error handling user left: ${error.message}`);
      }
    }
  ],
  ["ACTION_STARTED" /* ACTION_STARTED */]: [
    async (payload) => {
      logger.debug(`Action started: ${payload.actionName} (${payload.actionId})`);
    }
  ],
  ["ACTION_COMPLETED" /* ACTION_COMPLETED */]: [
    async (payload) => {
      const status = payload.error ? `failed: ${payload.error.message}` : "completed";
      logger.debug(`Action ${status}: ${payload.actionName} (${payload.actionId})`);
    }
  ],
  ["EVALUATOR_STARTED" /* EVALUATOR_STARTED */]: [
    async (payload) => {
      logger.debug(`Evaluator started: ${payload.evaluatorName} (${payload.evaluatorId})`);
    }
  ],
  ["EVALUATOR_COMPLETED" /* EVALUATOR_COMPLETED */]: [
    async (payload) => {
      const status = payload.error ? `failed: ${payload.error.message}` : "completed";
      logger.debug(`Evaluator ${status}: ${payload.evaluatorName} (${payload.evaluatorId})`);
    }
  ]
};
var bootstrapPlugin = {
  name: "bootstrap",
  description: "Agent bootstrap with basic actions and evaluators",
  actions: [
    replyAction,
    followRoomAction,
    unfollowRoomAction,
    ignoreAction,
    noneAction,
    muteRoomAction,
    unmuteRoomAction,
    sendMessageAction,
    updateEntityAction,
    choiceAction,
    roles_default,
    settings_default
  ],
  events,
  evaluators: [reflectionEvaluator],
  providers: [
    evaluatorsProvider,
    anxietyProvider,
    knowledgeProvider,
    timeProvider,
    entitiesProvider,
    relationshipsProvider,
    choiceProvider,
    factsProvider,
    roleProvider,
    settingsProvider,
    capabilitiesProvider,
    attachmentsProvider,
    providersProvider,
    actionsProvider,
    characterProvider,
    recentMessagesProvider
  ],
  services: [TaskService, ScenarioService]
};

// src/uuid.ts
import { sha1 } from "js-sha1";
import { z as z2 } from "zod";
var uuidSchema = z2.string().uuid();
function validateUuid(value) {
  const result = uuidSchema.safeParse(value);
  return result.success ? result.data : null;
}
function stringToUuid(target) {
  if (typeof target === "number") {
    target = target.toString();
  }
  if (typeof target !== "string") {
    throw TypeError("Value must be string");
  }
  const _uint8ToHex = (ubyte) => {
    const first = ubyte >> 4;
    const second = ubyte - (first << 4);
    const HEX_DIGITS = "0123456789abcdef".split("");
    return HEX_DIGITS[first] + HEX_DIGITS[second];
  };
  const _uint8ArrayToHex = (buf) => {
    let out = "";
    for (let i = 0; i < buf.length; i++) {
      out += _uint8ToHex(buf[i]);
    }
    return out;
  };
  const escapedStr = encodeURIComponent(target);
  const buffer = new Uint8Array(escapedStr.length);
  for (let i = 0; i < escapedStr.length; i++) {
    buffer[i] = escapedStr[i].charCodeAt(0);
  }
  const hash = sha1(buffer);
  const hashBuffer = new Uint8Array(hash.length / 2);
  for (let i = 0; i < hash.length; i += 2) {
    hashBuffer[i / 2] = Number.parseInt(hash.slice(i, i + 2), 16);
  }
  return `${_uint8ArrayToHex(hashBuffer.slice(0, 4))}-${_uint8ArrayToHex(hashBuffer.slice(4, 6))}-${_uint8ToHex(hashBuffer[6] & 15)}${_uint8ToHex(hashBuffer[7])}-${_uint8ToHex(hashBuffer[8] & 63 | 128)}${_uint8ToHex(hashBuffer[9])}-${_uint8ArrayToHex(hashBuffer.slice(10, 16))}`;
}

// src/runtime.ts
import fs2 from "node:fs";
import path2 from "node:path";
var environmentSettings = {};
function loadEnvConfig() {
  if (typeof window !== "undefined" && typeof window.document !== "undefined") {
    return environmentSettings;
  }
  let dotenv = null;
  try {
    if (typeof process !== "undefined" && process.versions && process.versions.node) {
      dotenv = __require("dotenv");
    }
  } catch (err) {
    logger_default.debug("dotenv module not available");
  }
  function findNearestEnvFile(startDir = process.cwd()) {
    let currentDir = startDir;
    while (currentDir !== path2.parse(currentDir).root) {
      const envPath2 = path2.join(currentDir, ".env");
      if (fs2.existsSync(envPath2)) {
        return envPath2;
      }
      currentDir = path2.dirname(currentDir);
    }
    const rootEnvPath = path2.join(path2.parse(currentDir).root, ".env");
    return fs2.existsSync(rootEnvPath) ? rootEnvPath : null;
  }
  const envPath = findNearestEnvFile();
  try {
    if (dotenv) {
      const result = dotenv.config(envPath ? { path: envPath } : {});
      if (!result.error && envPath) {
        logger_default.log(`Loaded .env file from: ${envPath}`);
      }
    }
  } catch (err) {
    logger_default.warn("Failed to load .env file:", err);
  }
  const env = typeof process !== "undefined" ? process.env : import.meta.env;
  const namespacedSettings = parseNamespacedSettings(env);
  if (typeof process !== "undefined") {
    Object.entries(namespacedSettings).forEach(([namespace, settings]) => {
      process.env[`__namespaced_${namespace}`] = JSON.stringify(settings);
    });
  }
  return env;
}
function parseNamespacedSettings(env) {
  const namespaced = {};
  for (const [key, value] of Object.entries(env)) {
    if (!value) continue;
    const [namespace, ...rest] = key.split(".");
    if (!namespace || rest.length === 0) continue;
    const settingKey = rest.join(".");
    namespaced[namespace] = namespaced[namespace] || {};
    namespaced[namespace][settingKey] = value;
  }
  return namespaced;
}
var Semaphore = class {
  permits;
  waiting = [];
  constructor(count) {
    this.permits = count;
  }
  async acquire() {
    if (this.permits > 0) {
      this.permits -= 1;
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      this.waiting.push(resolve);
    });
  }
  release() {
    this.permits += 1;
    const nextResolve = this.waiting.shift();
    if (nextResolve && this.permits > 0) {
      this.permits -= 1;
      nextResolve();
    }
  }
};
var AgentRuntime = class {
  #conversationLength = 32;
  agentId;
  character;
  adapter;
  actions = [];
  evaluators = [];
  providers = [];
  plugins = [];
  events = /* @__PURE__ */ new Map();
  stateCache = /* @__PURE__ */ new Map();
  fetch = fetch;
  services = /* @__PURE__ */ new Map();
  models = /* @__PURE__ */ new Map();
  routes = [];
  taskWorkers = /* @__PURE__ */ new Map();
  // Event emitter methods
  eventHandlers = /* @__PURE__ */ new Map();
  runtimeLogger;
  knowledgeProcessingSemaphore = new Semaphore(10);
  settings;
  constructor(opts) {
    this.agentId = opts.character?.id ?? opts?.agentId ?? stringToUuid(opts.character?.name ?? uuidv43());
    this.character = opts.character;
    const logLevel = process.env.LOG_LEVEL || "info";
    this.runtimeLogger = logger_default.child({
      agentName: this.character?.name,
      agentId: this.agentId,
      level: logLevel === "debug" ? "debug" : "error"
      // Show only errors unless debug mode is enabled
    });
    this.runtimeLogger.debug(`[AgentRuntime] Process working directory: ${process.cwd()}`);
    this.#conversationLength = opts.conversationLength ?? this.#conversationLength;
    if (opts.adapter) {
      this.registerDatabaseAdapter(opts.adapter);
    }
    this.fetch = opts.fetch ?? this.fetch;
    if (typeof window !== "undefined" && typeof window.document !== "undefined") {
      this.settings = environmentSettings;
    } else {
      this.settings = loadEnvConfig();
    }
    const plugins = opts?.plugins ?? [];
    if (!opts?.ignoreBootstrap) {
      plugins.push(bootstrapPlugin);
    }
    this.plugins = plugins;
    this.runtimeLogger.debug(`Success: Agent ID: ${this.agentId}`);
  }
  /**
   * Registers a plugin with the runtime and initializes its components
   * @param plugin The plugin to register
   */
  async registerPlugin(plugin) {
    if (!plugin) {
      this.runtimeLogger.error("*** registerPlugin plugin is undefined");
      throw new Error("*** registerPlugin plugin is undefined");
    }
    if (!this.plugins.some((p) => p.name === plugin.name)) {
      this.plugins.push(plugin);
      this.runtimeLogger.debug(`Success: Plugin ${plugin.name} registered successfully`);
    }
    if (plugin.init) {
      try {
        await plugin.init(plugin.config || {}, this);
        this.runtimeLogger.debug(`Success: Plugin ${plugin.name} initialized successfully`);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        if (errorMessage.includes("API key") || errorMessage.includes("environment variables") || errorMessage.includes("Invalid plugin configuration")) {
          console.warn(`Plugin ${plugin.name} requires configuration. ${errorMessage}`);
          console.warn(
            "Please check your environment variables and ensure all required API keys are set."
          );
          console.warn("You can set these in your .eliza/.env file.");
        } else {
          throw error;
        }
      }
    }
    if (plugin.adapter) {
      this.runtimeLogger.debug(`Registering database adapter for plugin ${plugin.name}`);
      this.registerDatabaseAdapter(plugin.adapter);
    }
    if (plugin.actions) {
      for (const action of plugin.actions) {
        this.registerAction(action);
      }
    }
    if (plugin.evaluators) {
      for (const evaluator of plugin.evaluators) {
        this.registerEvaluator(evaluator);
      }
    }
    if (plugin.providers) {
      for (const provider of plugin.providers) {
        this.registerContextProvider(provider);
      }
    }
    if (plugin.models) {
      for (const [modelType, handler2] of Object.entries(plugin.models)) {
        this.registerModel(modelType, handler2);
      }
    }
    if (plugin.routes) {
      for (const route of plugin.routes) {
        this.routes.push(route);
      }
    }
    if (plugin.events) {
      for (const [eventName, eventHandlers] of Object.entries(plugin.events)) {
        for (const eventHandler of eventHandlers) {
          this.registerEvent(eventName, eventHandler);
        }
      }
    }
    if (plugin.services) {
      await Promise.all(plugin.services.map((service) => this.registerService(service)));
    }
  }
  getAllServices() {
    return this.services;
  }
  async stop() {
    this.runtimeLogger.debug(`runtime::stop - character ${this.character.name}`);
    for (const [serviceName, service] of this.services) {
      this.runtimeLogger.debug(`runtime::stop - requesting service stop for ${serviceName}`);
      await service.stop();
    }
  }
  async initialize() {
    const registeredPluginNames = /* @__PURE__ */ new Set();
    const pluginRegistrationPromises = [];
    if (this.character.plugins) {
      const characterPlugins = await handlePluginImporting(this.character.plugins);
      for (const plugin of characterPlugins) {
        if (plugin && !registeredPluginNames.has(plugin.name)) {
          registeredPluginNames.add(plugin.name);
          pluginRegistrationPromises.push(await this.registerPlugin(plugin));
        }
      }
    }
    for (const plugin of [...this.plugins]) {
      if (plugin && !registeredPluginNames.has(plugin.name)) {
        registeredPluginNames.add(plugin.name);
        pluginRegistrationPromises.push(await this.registerPlugin(plugin));
      }
    }
    await this.adapter.init();
    try {
      const agentExists = await this.adapter.ensureAgentExists(this.character);
      const agent = await this.adapter.getAgent(this.agentId);
      if (!agent) {
        throw new Error(
          `Agent ${this.agentId} does not exist in database after ensureAgentExists call`
        );
      }
      const agentEntity = await this.adapter.getEntityById(this.agentId);
      if (!agentEntity) {
        const created = await this.createEntity({
          id: this.agentId,
          agentId: this.agentId,
          names: Array.from(new Set([this.character.name].filter(Boolean))),
          metadata: {}
        });
        if (!created) {
          throw new Error(`Failed to create entity for agent ${this.agentId}`);
        }
        this.runtimeLogger.debug(
          `Success: Agent entity created successfully for ${this.character.name}`
        );
      }
    } catch (error) {
      this.runtimeLogger.error(
        `Failed to create agent entity: ${error instanceof Error ? error.message : String(error)}`
      );
      throw error;
    }
    try {
      await Promise.all([
        this.ensureRoomExists({
          id: this.agentId,
          name: this.character.name,
          source: "self",
          type: "SELF" /* SELF */
        }),
        ...pluginRegistrationPromises
      ]);
    } catch (error) {
      this.runtimeLogger.error(
        `Failed to initialize: ${error instanceof Error ? error.message : String(error)}`
      );
      throw error;
    }
    try {
      const participants = await this.adapter.getParticipantsForRoom(this.agentId);
      if (!participants.includes(this.agentId)) {
        const added = await this.adapter.addParticipant(this.agentId, this.agentId);
        if (!added) {
          throw new Error(`Failed to add agent ${this.agentId} as participant to its own room`);
        }
        this.runtimeLogger.debug(
          `Agent ${this.character.name} linked to its own room successfully`
        );
      }
    } catch (error) {
      this.runtimeLogger.error(
        `Failed to add agent as participant: ${error instanceof Error ? error.message : String(error)}`
      );
      throw error;
    }
    const embeddingModel = this.getModel(ModelType.TEXT_EMBEDDING);
    if (!embeddingModel) {
      this.runtimeLogger.warn(
        `[AgentRuntime][${this.character.name}] No TEXT_EMBEDDING model registered. Skipping embedding dimension setup.`
      );
    } else {
      await this.ensureEmbeddingDimension();
    }
    if (this.character?.knowledge && this.character.knowledge.length > 0) {
      const stringKnowledge = this.character.knowledge.filter(
        (item) => typeof item === "string"
      );
      await this.processCharacterKnowledge(stringKnowledge);
    }
  }
  async handleProcessingError(error, context) {
    this.runtimeLogger.error(`Error ${context}:`, error?.message || error || "Unknown error");
    throw error;
  }
  async checkExistingKnowledge(knowledgeId) {
    const existingDocument = await this.getMemoryById(knowledgeId);
    return !!existingDocument;
  }
  async getKnowledge(message) {
    if (!message?.content?.text) {
      this.runtimeLogger.warn("Invalid message for knowledge query:", {
        message,
        content: message?.content,
        text: message?.content?.text
      });
      return [];
    }
    if (!message?.content?.text || message?.content?.text.trim().length === 0) {
      this.runtimeLogger.warn("Empty text for knowledge query");
      return [];
    }
    const embedding = await this.useModel(ModelType.TEXT_EMBEDDING, {
      text: message?.content?.text
    });
    const fragments = await this.searchMemories({
      tableName: "knowledge",
      embedding,
      roomId: message.agentId,
      count: 5,
      match_threshold: 0.1
    });
    const uniqueSources = [
      ...new Set(
        fragments.map((memory) => {
          this.runtimeLogger.debug(
            `Matched fragment: ${memory.content.text} with similarity: ${memory.similarity}`
          );
          return memory?.metadata?.type === "fragment" /* FRAGMENT */ ? memory?.metadata?.documentId : void 0;
        }).filter(Boolean)
      )
    ];
    const knowledgeDocuments = await Promise.all(
      uniqueSources.map((source) => this.getMemoryById(source))
    );
    return knowledgeDocuments.filter((memory) => memory !== null).map((memory) => ({ id: memory.id, content: memory.content }));
  }
  async addKnowledge(item, options2 = {
    targetTokens: 3e3,
    overlap: 200,
    modelContextSize: 4096
  }) {
    const documentMemory = {
      id: item.id,
      agentId: this.agentId,
      roomId: this.agentId,
      entityId: this.agentId,
      content: item.content,
      metadata: item.metadata || {
        type: "document" /* DOCUMENT */,
        timestamp: Date.now()
      }
    };
    await this.createMemory(documentMemory, "documents");
    const fragments = await splitChunks(item.content.text, options2.targetTokens, options2.overlap);
    for (let i = 0; i < fragments.length; i++) {
      const embedding = await this.useModel(ModelType.TEXT_EMBEDDING, fragments[i]);
      const fragmentMemory = {
        id: createUniqueUuid(this, `${item.id}-fragment-${i}`),
        agentId: this.agentId,
        roomId: this.agentId,
        entityId: this.agentId,
        embedding,
        content: { text: fragments[i] },
        metadata: {
          type: "fragment" /* FRAGMENT */,
          documentId: item.id,
          // Link to source document
          position: i,
          // Keep track of order
          timestamp: Date.now()
        }
      };
      await this.createMemory(fragmentMemory, "knowledge");
    }
  }
  async processCharacterKnowledge(items) {
    const processingPromises = items.map(async (item) => {
      await this.knowledgeProcessingSemaphore.acquire();
      try {
        const knowledgeId = createUniqueUuid(this, item);
        if (await this.checkExistingKnowledge(knowledgeId)) {
          return;
        }
        this.runtimeLogger.debug(
          "Processing knowledge for ",
          this.character.name,
          " - ",
          item.slice(0, 100)
        );
        let metadata = {
          type: "document" /* DOCUMENT */,
          timestamp: Date.now()
        };
        const pathMatch = item.match(/^Path: (.+?)(?:\n|\r\n)/);
        if (pathMatch) {
          const filePath = pathMatch[1].trim();
          const extension = filePath.split(".").pop() || "";
          const filename = filePath.split("/").pop() || "";
          const title = filename.replace(`.${extension}`, "");
          metadata = {
            ...metadata,
            path: filePath,
            filename,
            fileExt: extension,
            title,
            fileType: `text/${extension || "plain"}`,
            fileSize: item.length,
            source: "character"
          };
        }
        await this.addKnowledge({
          id: knowledgeId,
          content: {
            text: item
          },
          metadata
        });
      } catch (error) {
        await this.handleProcessingError(error, "processing character knowledge");
      } finally {
        this.knowledgeProcessingSemaphore.release();
      }
    });
    await Promise.all(processingPromises);
  }
  setSetting(key, value, secret = false) {
    if (secret) {
      if (!this.character.secrets) {
        this.character.secrets = {};
      }
      this.character.secrets[key] = value;
    } else {
      if (!this.character.settings) {
        this.character.settings = {};
      }
      this.character.settings[key] = value;
    }
  }
  getSetting(key) {
    const value = this.character.secrets?.[key] || this.character.settings?.[key] || this.character.settings?.secrets?.[key] || this.settings[key];
    if (value === "true") return true;
    if (value === "false") return false;
    return value || null;
  }
  /**
   * Get the number of messages that are kept in the conversation buffer.
   * @returns The number of recent messages to be kept in memory.
   */
  getConversationLength() {
    return this.#conversationLength;
  }
  registerDatabaseAdapter(adapter) {
    if (this.adapter) {
      this.runtimeLogger.warn(
        "Database adapter already registered. Additional adapters will be ignored. This may lead to unexpected behavior."
      );
    } else {
      this.adapter = adapter;
      this.runtimeLogger.debug("Success: Database adapter registered successfully.");
    }
  }
  /**
   * Register a provider for the agent to use.
   * @param provider The provider to register.
   */
  registerProvider(provider) {
    this.providers.push(provider);
    this.runtimeLogger.debug(`Success: Provider ${provider.name} registered successfully.`);
  }
  /**
   * Register an action for the agent to perform.
   * @param action The action to register.
   */
  registerAction(action) {
    this.runtimeLogger.debug(
      `${this.character.name}(${this.agentId}) - Registering action: ${action.name}`
    );
    if (this.actions.find((a) => a.name === action.name)) {
      this.runtimeLogger.warn(
        `${this.character.name}(${this.agentId}) - Action ${action.name} already exists. Skipping registration.`
      );
    } else {
      this.actions.push(action);
      this.runtimeLogger.debug(
        `${this.character.name}(${this.agentId}) - Action ${action.name} registered successfully.`
      );
    }
  }
  /**
   * Register an evaluator to assess and guide the agent's responses.
   * @param evaluator The evaluator to register.
   */
  registerEvaluator(evaluator) {
    this.evaluators.push(evaluator);
  }
  /**
   * Register a context provider to provide context for message generation.
   * @param provider The context provider to register.
   */
  registerContextProvider(provider) {
    this.providers.push(provider);
  }
  /**
   * Process the actions of a message.
   * @param message The message to process.
   * @param responses The array of response memories to process actions from.
   * @param state Optional state object for the action processing.
   * @param callback Optional callback handler for action results.
   */
  async processActions(message, responses, state, callback) {
    for (const response of responses) {
      let normalizeAction = function(action) {
        return action.toLowerCase().replace("_", "");
      };
      if (!response.content?.actions || response.content.actions.length === 0) {
        this.runtimeLogger.warn("No action found in the response content.");
        continue;
      }
      const actions = response.content.actions;
      this.runtimeLogger.debug(
        `Found actions: ${this.actions.map((a) => normalizeAction(a.name))}`
      );
      for (const responseAction of actions) {
        state = await this.composeState(message, ["RECENT_MESSAGES"]);
        this.runtimeLogger.debug(`Success: Calling action: ${responseAction}`);
        const normalizedResponseAction = normalizeAction(responseAction);
        let action = this.actions.find(
          (a) => normalizeAction(a.name).includes(normalizedResponseAction) || // the || is kind of a fuzzy match
          normalizedResponseAction.includes(normalizeAction(a.name))
          //
        );
        if (action) {
          this.runtimeLogger.debug(`Success: Found action: ${action?.name}`);
        } else {
          this.runtimeLogger.debug("Attempting to find action in similes.");
          for (const _action of this.actions) {
            const simileAction = _action.similes?.find(
              (simile) => simile.toLowerCase().replace("_", "").includes(normalizedResponseAction) || normalizedResponseAction.includes(simile.toLowerCase().replace("_", ""))
            );
            if (simileAction) {
              action = _action;
              this.runtimeLogger.debug(`Success: Action found in similes: ${action.name}`);
              break;
            }
          }
        }
        if (!action) {
          this.runtimeLogger.error(`No action found for: ${responseAction}`);
          continue;
        }
        if (!action.handler) {
          this.runtimeLogger.error(`Action ${action.name} has no handler.`);
          continue;
        }
        try {
          this.runtimeLogger.debug(`Executing handler for action: ${action.name}`);
          await action.handler(this, message, state, {}, callback, responses);
          this.runtimeLogger.debug(`Success: Action ${action.name} executed successfully.`);
          this.adapter.log({
            entityId: message.entityId,
            roomId: message.roomId,
            type: "action",
            body: {
              action: action.name,
              message: message.content.text,
              messageId: message.id,
              state,
              responses
            }
          });
        } catch (error) {
          this.runtimeLogger.error(error);
          throw error;
        }
      }
    }
  }
  /**
   * Evaluate the message and state using the registered evaluators.
   * @param message The message to evaluate.
   * @param state The state of the agent.
   * @param didRespond Whether the agent responded to the message.~
   * @param callback The handler callback
   * @returns The results of the evaluation.
   */
  async evaluate(message, state, didRespond, callback, responses) {
    const evaluatorPromises = this.evaluators.map(async (evaluator) => {
      if (!evaluator.handler) {
        return null;
      }
      if (!didRespond && !evaluator.alwaysRun) {
        return null;
      }
      const result = await evaluator.validate(this, message, state);
      if (result) {
        return evaluator;
      }
      return null;
    });
    const evaluators = (await Promise.all(evaluatorPromises)).filter(Boolean);
    if (evaluators.length === 0) {
      return [];
    }
    state = await this.composeState(message, ["RECENT_MESSAGES", "EVALUATORS"]);
    await Promise.all(
      evaluators.map(async (evaluator) => {
        if (evaluator.handler) {
          await evaluator.handler(this, message, state, {}, callback, responses);
          this.adapter.log({
            entityId: message.entityId,
            roomId: message.roomId,
            type: "evaluator",
            body: {
              evaluator: evaluator.name,
              messageId: message.id,
              message: message.content.text,
              state
            }
          });
        }
      })
    );
    return evaluators;
  }
  async ensureConnection({
    entityId,
    roomId,
    userName,
    name,
    source,
    type,
    channelId,
    serverId,
    worldId
  }) {
    if (entityId === this.agentId) {
      throw new Error("Agent should not connect to itself");
    }
    if (!worldId && serverId) {
      worldId = createUniqueUuid(this, serverId);
    }
    const names4 = [name, userName].filter(Boolean);
    const metadata = {
      [source]: {
        name,
        userName
      }
    };
    try {
      let entity = await this.adapter.getEntityById(entityId);
      if (!entity) {
        try {
          const success = await this.adapter.createEntity({
            id: entityId,
            names: names4,
            metadata,
            agentId: this.agentId
          });
          if (success) {
            this.runtimeLogger.debug(
              `Created new entity ${entityId} for user ${name || userName || "unknown"}`
            );
          } else {
            throw new Error(`Failed to create entity ${entityId}`);
          }
        } catch (error) {
          if (error.message?.includes("duplicate key") || error.code === "23505") {
            this.runtimeLogger.debug(
              `Entity ${entityId} exists in database but not for this agent. This is normal in multi-agent setups.`
            );
          } else {
            throw error;
          }
        }
      } else {
        await this.adapter.updateEntity({
          id: entityId,
          names: [.../* @__PURE__ */ new Set([...entity.names || [], ...names4])].filter(Boolean),
          metadata: {
            ...entity.metadata,
            [source]: {
              ...entity.metadata?.[source],
              name,
              userName
            }
          },
          agentId: this.agentId
        });
      }
      if (worldId) {
        await this.ensureWorldExists({
          id: worldId,
          name: serverId ? `World for server ${serverId}` : `World for room ${roomId}`,
          agentId: this.agentId,
          serverId: serverId || "default",
          metadata
        });
      }
      await this.ensureRoomExists({
        id: roomId,
        name,
        source,
        type,
        channelId,
        serverId,
        worldId
      });
      try {
        await this.ensureParticipantInRoom(entityId, roomId);
      } catch (error) {
        if (error.message?.includes("not found")) {
          const added = await this.adapter.addParticipant(entityId, roomId);
          if (!added) {
            throw new Error(`Failed to add participant ${entityId} to room ${roomId}`);
          }
          this.runtimeLogger.debug(`Added participant ${entityId} to room ${roomId} directly`);
        } else {
          throw error;
        }
      }
      await this.ensureParticipantInRoom(this.agentId, roomId);
      this.runtimeLogger.debug(
        `Success: Successfully connected entity ${entityId} in room ${roomId}`
      );
    } catch (error) {
      this.runtimeLogger.error(
        `Failed to ensure connection: ${error instanceof Error ? error.message : String(error)}`
      );
      throw error;
    }
  }
  /**
   * Ensures a participant is added to a room, checking that the entity exists first
   */
  async ensureParticipantInRoom(entityId, roomId) {
    const entity = await this.adapter.getEntityById(entityId);
    if (!entity && entityId !== this.agentId) {
      this.runtimeLogger.warn(
        `Entity ${entityId} not directly accessible to agent ${this.agentId}. Will attempt to add as participant anyway.`
      );
    } else if (!entity) {
      throw new Error(`User ${entityId} not found`);
    }
    const participants = await this.adapter.getParticipantsForRoom(roomId);
    if (!participants.includes(entityId)) {
      const added = await this.adapter.addParticipant(entityId, roomId);
      if (!added) {
        throw new Error(`Failed to add participant ${entityId} to room ${roomId}`);
      }
      if (entityId === this.agentId) {
        this.runtimeLogger.debug(
          `Agent ${this.character.name} linked to room ${roomId} successfully.`
        );
      } else {
        this.runtimeLogger.debug(`User ${entityId} linked to room ${roomId} successfully.`);
      }
    }
  }
  async removeParticipant(entityId, roomId) {
    return await this.adapter.removeParticipant(entityId, roomId);
  }
  async getParticipantsForEntity(entityId) {
    return await this.adapter.getParticipantsForEntity(entityId);
  }
  async getParticipantsForRoom(roomId) {
    return await this.adapter.getParticipantsForRoom(roomId);
  }
  async addParticipant(entityId, roomId) {
    return await this.adapter.addParticipant(entityId, roomId);
  }
  /**
   * Ensure the existence of a world.
   */
  async ensureWorldExists({ id, name, serverId, metadata }) {
    const world = await this.getWorld(id);
    if (!world) {
      this.runtimeLogger.debug("Creating world:", {
        id,
        name,
        serverId,
        agentId: this.agentId
      });
      await this.adapter.createWorld({
        id,
        name,
        agentId: this.agentId,
        serverId: serverId || "default",
        metadata
      });
      this.runtimeLogger.debug(`World ${id} created successfully.`);
    }
  }
  /**
   * Ensure the existence of a room between the agent and a user. If no room exists, a new room is created and the user
   * and agent are added as participants. The room ID is returned.
   * @param entityId - The user ID to create a room with.
   * @returns The room ID of the room between the agent and the user.
   * @throws An error if the room cannot be created.
   */
  async ensureRoomExists({ id, name, source, type, channelId, serverId, worldId, metadata }) {
    const room = await this.adapter.getRoom(id);
    if (!room) {
      await this.adapter.createRoom({
        id,
        name,
        agentId: this.agentId,
        source,
        type,
        channelId,
        serverId,
        worldId,
        metadata
      });
      this.runtimeLogger.debug(`Room ${id} created successfully.`);
    }
  }
  /**
   * Composes the agent's state by gathering data from enabled providers.
   * @param message - The message to use as context for state composition
   * @param filterList - Optional list of provider names to include, filtering out all others
   * @param includeList - Optional list of private provider names to include that would otherwise be filtered out
   * @returns A State object containing provider data, values, and text
   */
  async composeState(message, filterList = null, includeList = null) {
    const cachedState = await this.stateCache.get(message.id) || {
      values: {},
      data: {},
      text: ""
    };
    const existingProviderNames = cachedState.data.providers ? Object.keys(cachedState.data.providers) : [];
    const providerNames = /* @__PURE__ */ new Set();
    if (filterList && filterList.length > 0) {
      filterList.forEach((name) => providerNames.add(name));
    } else {
      this.providers.filter((p) => !p.private && !p.dynamic && !existingProviderNames.includes(p.name)).forEach((p) => providerNames.add(p.name));
    }
    if (includeList && includeList.length > 0) {
      includeList.forEach((name) => providerNames.add(name));
    }
    const providersToGet = Array.from(
      new Set(this.providers.filter((p) => providerNames.has(p.name)))
    ).sort((a, b) => (a.position || 0) - (b.position || 0));
    const providerData = await Promise.all(
      providersToGet.map(async (provider) => {
        const start = Date.now();
        const result = await provider.get(this, message, cachedState);
        const duration = Date.now() - start;
        this.runtimeLogger.debug(`${provider.name} Provider took ${duration}ms to respond`);
        return {
          ...result,
          providerName: provider.name
        };
      })
    );
    const existingProviderData = cachedState.data.providers || {};
    const combinedValues = { ...existingProviderData };
    for (const result of providerData) {
      combinedValues[result.providerName] = result.values || {};
    }
    const newProvidersText = providerData.map((result) => result.text).filter((text) => text !== "").join("\n");
    let providersText = "";
    if (cachedState.text && newProvidersText) {
      providersText = `${cachedState.text}
${newProvidersText}`;
    } else if (newProvidersText) {
      providersText = newProvidersText;
    } else if (cachedState.text) {
      providersText = cachedState.text;
    }
    const values = {
      ...cachedState.values || {}
    };
    for (const providerName in combinedValues) {
      const providerValues = combinedValues[providerName];
      if (providerValues && typeof providerValues === "object") {
        Object.assign(values, providerValues);
      }
    }
    const newState = {
      values: {
        ...values,
        providers: providersText
      },
      data: {
        ...cachedState.data || {},
        providers: combinedValues
      },
      text: providersText
    };
    this.stateCache.set(message.id, newState);
    return newState;
  }
  getService(service) {
    const serviceInstance = this.services.get(service);
    if (!serviceInstance) {
      this.runtimeLogger.warn(`Service ${service} not found`);
      return null;
    }
    return serviceInstance;
  }
  async registerService(service) {
    const serviceType = service.serviceType;
    if (!serviceType) {
      return;
    }
    this.runtimeLogger.debug(
      `${this.character.name}(${this.agentId}) - Registering service:`,
      serviceType
    );
    if (this.services.has(serviceType)) {
      this.runtimeLogger.warn(
        `${this.character.name}(${this.agentId}) - Service ${serviceType} is already registered. Skipping registration.`
      );
      return;
    }
    const serviceInstance = await service.start(this);
    this.services.set(serviceType, serviceInstance);
    this.runtimeLogger.debug(
      `${this.character.name}(${this.agentId}) - Service ${serviceType} registered successfully`
    );
  }
  registerModel(modelType, handler2) {
    const modelKey = typeof modelType === "string" ? modelType : ModelType[modelType];
    if (!this.models.has(modelKey)) {
      this.models.set(modelKey, []);
    }
    this.models.get(modelKey)?.push(handler2);
  }
  getModel(modelType) {
    const modelKey = typeof modelType === "string" ? modelType : ModelType[modelType];
    const models = this.models.get(modelKey);
    if (!models?.length) {
      return void 0;
    }
    return models[0];
  }
  /**
   * Use a model with strongly typed parameters and return values based on model type
   * @template T - The model type to use
   * @template R - The expected return type, defaults to the type defined in ModelResultMap[T]
   * @param {T} modelType - The type of model to use
   * @param {ModelParamsMap[T] | any} params - The parameters for the model, typed based on model type
   * @returns {Promise<R>} - The model result, typed based on the provided generic type parameter
   */
  async useModel(modelType, params) {
    const modelKey = typeof modelType === "string" ? modelType : ModelType[modelType];
    const model = this.getModel(modelKey);
    if (!model) {
      throw new Error(`No handler found for delegate type: ${modelKey}`);
    }
    this.runtimeLogger.debug(`[useModel] ${modelKey} input:`, JSON.stringify(params, null, 2));
    let paramsWithRuntime;
    if (params === null || params === void 0 || typeof params !== "object" || Array.isArray(params) || typeof Buffer !== "undefined" && Buffer.isBuffer(params)) {
      paramsWithRuntime = params;
    } else {
      paramsWithRuntime = {
        ...params,
        runtime: this
      };
    }
    const startTime = performance.now();
    const response = await model(this, paramsWithRuntime);
    const elapsedTime = performance.now() - startTime;
    this.runtimeLogger.debug(`[useModel] ${modelKey} completed in ${elapsedTime.toFixed(2)}ms`);
    this.runtimeLogger.debug(
      `[useModel] ${modelKey} output:`,
      // if response is an array, should the first and last 5 items with a "..." in the middle, and a (x items) at the end
      Array.isArray(response) ? `${JSON.stringify(response.slice(0, 5))}...${JSON.stringify(
        response.slice(-5)
      )} (${response.length} items)` : JSON.stringify(response)
    );
    this.adapter.log({
      entityId: this.agentId,
      roomId: this.agentId,
      body: {
        modelType,
        modelKey,
        params: params ? typeof params === "object" ? Object.keys(params) : typeof params : null,
        response: Array.isArray(response) && response.every((x) => typeof x === "number") ? "[array]" : response
      },
      type: `useModel:${modelKey}`
    });
    return response;
  }
  registerEvent(event, handler2) {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event)?.push(handler2);
  }
  getEvent(event) {
    return this.events.get(event);
  }
  async emitEvent(event, params) {
    const events2 = Array.isArray(event) ? event : [event];
    for (const eventName of events2) {
      const eventHandlers = this.events.get(eventName);
      if (eventHandlers) {
        await Promise.all(eventHandlers.map((handler2) => handler2(params)));
      }
    }
  }
  async ensureEmbeddingDimension() {
    this.runtimeLogger.debug(
      `[AgentRuntime][${this.character.name}] Starting ensureEmbeddingDimension`
    );
    if (!this.adapter) {
      throw new Error(
        `[AgentRuntime][${this.character.name}] Database adapter not initialized before ensureEmbeddingDimension`
      );
    }
    try {
      const model = this.getModel(ModelType.TEXT_EMBEDDING);
      if (!model) {
        throw new Error(
          `[AgentRuntime][${this.character.name}] No TEXT_EMBEDDING model registered`
        );
      }
      this.runtimeLogger.debug(
        `[AgentRuntime][${this.character.name}] Getting embedding dimensions`
      );
      const embedding = await this.useModel(ModelType.TEXT_EMBEDDING, null);
      if (!embedding || !embedding.length) {
        throw new Error(`[AgentRuntime][${this.character.name}] Invalid embedding received`);
      }
      this.runtimeLogger.debug(
        `[AgentRuntime][${this.character.name}] Setting embedding dimension: ${embedding.length}`
      );
      await this.adapter.ensureEmbeddingDimension(embedding.length);
      this.runtimeLogger.debug(
        `[AgentRuntime][${this.character.name}] Successfully set embedding dimension`
      );
    } catch (error) {
      this.runtimeLogger.debug(
        `[AgentRuntime][${this.character.name}] Error in ensureEmbeddingDimension:`,
        error
      );
      throw error;
    }
  }
  registerTaskWorker(taskHandler) {
    if (this.taskWorkers.has(taskHandler.name)) {
      this.runtimeLogger.warn(
        `Task definition ${taskHandler.name} already registered. Will be overwritten.`
      );
    }
    this.taskWorkers.set(taskHandler.name, taskHandler);
  }
  /**
   * Get a task worker by name
   */
  getTaskWorker(name) {
    return this.taskWorkers.get(name);
  }
  // Implement database adapter methods
  get db() {
    return this.adapter.db;
  }
  async init() {
    await this.adapter.init();
  }
  async close() {
    await this.adapter.close();
  }
  async getAgent(agentId) {
    return await this.adapter.getAgent(agentId);
  }
  async getAgents() {
    return await this.adapter.getAgents();
  }
  async createAgent(agent) {
    return await this.adapter.createAgent(agent);
  }
  async updateAgent(agentId, agent) {
    return await this.adapter.updateAgent(agentId, agent);
  }
  async deleteAgent(agentId) {
    return await this.adapter.deleteAgent(agentId);
  }
  async ensureAgentExists(agent) {
    await this.adapter.ensureAgentExists(agent);
  }
  async getEntityById(entityId) {
    return await this.adapter.getEntityById(entityId);
  }
  async getEntitiesForRoom(roomId, includeComponents) {
    return await this.adapter.getEntitiesForRoom(roomId, includeComponents);
  }
  async createEntity(entity) {
    if (!entity.agentId) {
      entity.agentId = this.agentId;
    }
    return await this.adapter.createEntity(entity);
  }
  async updateEntity(entity) {
    await this.adapter.updateEntity(entity);
  }
  async getComponent(entityId, type, worldId, sourceEntityId) {
    return await this.adapter.getComponent(entityId, type, worldId, sourceEntityId);
  }
  async getComponents(entityId, worldId, sourceEntityId) {
    return await this.adapter.getComponents(entityId, worldId, sourceEntityId);
  }
  async createComponent(component) {
    return await this.adapter.createComponent(component);
  }
  async updateComponent(component) {
    await this.adapter.updateComponent(component);
  }
  async deleteComponent(componentId) {
    await this.adapter.deleteComponent(componentId);
  }
  async addEmbeddingToMemory(memory) {
    if (memory.embedding) {
      return memory;
    }
    const memoryText = memory.content.text;
    if (!memoryText) {
      throw new Error("Cannot generate embedding: Memory content is empty");
    }
    try {
      memory.embedding = await this.useModel(ModelType.TEXT_EMBEDDING, {
        text: memoryText
      });
    } catch (error) {
      logger_default.error("Failed to generate embedding:", error);
      memory.embedding = await this.useModel(ModelType.TEXT_EMBEDDING, null);
    }
    return memory;
  }
  async getMemories(params) {
    return await this.adapter.getMemories(params);
  }
  async getMemoryById(id) {
    return await this.adapter.getMemoryById(id);
  }
  async getMemoriesByIds(ids, tableName) {
    return await this.adapter.getMemoriesByIds(ids, tableName);
  }
  async getMemoriesByRoomIds(params) {
    return await this.adapter.getMemoriesByRoomIds(params);
  }
  async getCachedEmbeddings(params) {
    return await this.adapter.getCachedEmbeddings(params);
  }
  async log(params) {
    await this.adapter.log(params);
  }
  async searchMemories(params) {
    return await this.adapter.searchMemories(params);
  }
  async createMemory(memory, tableName, unique) {
    return await this.adapter.createMemory(memory, tableName, unique);
  }
  async updateMemory(memory) {
    return await this.adapter.updateMemory(memory);
  }
  async deleteMemory(memoryId) {
    await this.adapter.deleteMemory(memoryId);
  }
  async deleteAllMemories(roomId, tableName) {
    await this.adapter.deleteAllMemories(roomId, tableName);
  }
  async countMemories(roomId, unique, tableName) {
    return await this.adapter.countMemories(roomId, unique, tableName);
  }
  async getLogs(params) {
    return await this.adapter.getLogs(params);
  }
  async deleteLog(logId) {
    await this.adapter.deleteLog(logId);
  }
  async createWorld(world) {
    return await this.adapter.createWorld(world);
  }
  async getWorld(id) {
    return await this.adapter.getWorld(id);
  }
  async getAllWorlds() {
    return await this.adapter.getAllWorlds();
  }
  async updateWorld(world) {
    await this.adapter.updateWorld(world);
  }
  async getRoom(roomId) {
    return await this.adapter.getRoom(roomId);
  }
  async createRoom({ id, name, source, type, channelId, serverId, worldId }) {
    return await this.adapter.createRoom({
      id,
      name,
      source,
      type,
      channelId,
      serverId,
      worldId
    });
  }
  async deleteRoom(roomId) {
    await this.adapter.deleteRoom(roomId);
  }
  async updateRoom(room) {
    await this.adapter.updateRoom(room);
  }
  async getRoomsForParticipant(entityId) {
    return await this.adapter.getRoomsForParticipant(entityId);
  }
  async getRoomsForParticipants(userIds) {
    return await this.adapter.getRoomsForParticipants(userIds);
  }
  async getRooms(worldId) {
    return await this.adapter.getRooms(worldId);
  }
  async getParticipantUserState(roomId, entityId) {
    return await this.adapter.getParticipantUserState(roomId, entityId);
  }
  async setParticipantUserState(roomId, entityId, state) {
    await this.adapter.setParticipantUserState(roomId, entityId, state);
  }
  async createRelationship(params) {
    return await this.adapter.createRelationship(params);
  }
  async updateRelationship(relationship) {
    await this.adapter.updateRelationship(relationship);
  }
  async getRelationship(params) {
    return await this.adapter.getRelationship(params);
  }
  async getRelationships(params) {
    return await this.adapter.getRelationships(params);
  }
  async getCache(key) {
    return await this.adapter.getCache(key);
  }
  async setCache(key, value) {
    return await this.adapter.setCache(key, value);
  }
  async deleteCache(key) {
    return await this.adapter.deleteCache(key);
  }
  async createTask(task) {
    return await this.adapter.createTask(task);
  }
  async getTasks(params) {
    return await this.adapter.getTasks(params);
  }
  async getTask(id) {
    return await this.adapter.getTask(id);
  }
  async getTasksByName(name) {
    return await this.adapter.getTasksByName(name);
  }
  async updateTask(id, task) {
    await this.adapter.updateTask(id, task);
  }
  async deleteTask(id) {
    await this.adapter.deleteTask(id);
  }
  // Event emitter methods
  on(event, callback) {
    if (!this.eventHandlers.has(event)) {
      this.eventHandlers.set(event, []);
    }
    this.eventHandlers.get(event).push(callback);
  }
  off(event, callback) {
    if (!this.eventHandlers.has(event)) {
      return;
    }
    const handlers = this.eventHandlers.get(event);
    const index = handlers.indexOf(callback);
    if (index !== -1) {
      handlers.splice(index, 1);
    }
  }
  emit(event, data) {
    if (!this.eventHandlers.has(event)) {
      return;
    }
    for (const handler2 of this.eventHandlers.get(event)) {
      handler2(data);
    }
  }
};
export {
  AgentRuntime,
  AgentStatus,
  CacheKeyPrefix,
  ChannelType,
  DatabaseAdapter,
  EventType,
  KnowledgeScope,
  MemoryType,
  ModelType,
  PlatformPrefix,
  Role,
  SOCKET_MESSAGE_TYPE,
  Semaphore,
  Service,
  ServiceType,
  TEEMode,
  TeeType,
  addHeader,
  asUUID,
  booleanFooter,
  cleanJsonResponse,
  composeActionExamples,
  composePrompt,
  composePromptFromState,
  composeRandomUser,
  createMessageMemory,
  createServiceError,
  createUniqueUuid,
  dynamicImport,
  elizaLogger,
  extractAttributes,
  findEntityByName,
  findWorldForOwner,
  formatActionNames,
  formatActions,
  formatEntities,
  formatMessages,
  formatPosts,
  formatTimestamp,
  getBrowserService,
  getEntityDetails,
  getFileService,
  getMemoryText,
  getPdfService,
  getTypedService,
  getUserServerRole,
  getVideoService,
  getWorldSettings2 as getWorldSettings,
  handlePluginImporting,
  initializeOnboarding,
  isCustomMetadata,
  isDescriptionMetadata,
  isDocumentMemory,
  isDocumentMetadata,
  isFragmentMemory,
  isFragmentMetadata,
  isMessageMetadata,
  loadEnvConfig,
  logger,
  messageHandlerTemplate,
  normalizeJsonString,
  parseActionResponseFromText,
  parseBooleanFromText2 as parseBooleanFromText,
  parseJSONObjectFromText,
  parseJsonArrayFromText,
  postActionResponseFooter,
  postCreationTemplate,
  registerDynamicImport,
  shouldRespondTemplate,
  splitChunks,
  stringArrayFooter,
  stringToUuid,
  trimTokens,
  truncateToCompleteSentence,
  updateWorldSettings2 as updateWorldSettings,
  uuidSchema,
  validateUuid
};
